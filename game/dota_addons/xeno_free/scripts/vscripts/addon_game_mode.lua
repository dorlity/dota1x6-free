
if my_game == nil then
    _G.my_game = class({})
end




LinkLuaModifier("modifier_tower_level", "modifiers/modifier_tower_level.lua", LUA_MODIFIER_MOTION_NONE)
LinkLuaModifier("modifier_on_respawn", "modifiers/modifier_on_respawn.lua", LUA_MODIFIER_MOTION_NONE)
LinkLuaModifier("modifier_death", "modifiers/modifier_death", LUA_MODIFIER_MOTION_NONE)
LinkLuaModifier( "modifier_roshan_upgrade", "modifiers/modifier_roshan_upgrade", LUA_MODIFIER_MOTION_NONE )
LinkLuaModifier( "modifier_player_damage", "modifiers/modifier_player_damage", LUA_MODIFIER_MOTION_NONE )
LinkLuaModifier( "modifier_bounty_map", "modifiers/modifier_bounty_map", LUA_MODIFIER_MOTION_NONE )
LinkLuaModifier( "modifier_aegis_custom", "modifiers/modifier_aegis_custom", LUA_MODIFIER_MOTION_NONE )
LinkLuaModifier( "modifier_tower_damage", "modifiers/modifier_tower_damage", LUA_MODIFIER_MOTION_NONE )
LinkLuaModifier( "modifier_target", "modifiers/modifier_target", LUA_MODIFIER_MOTION_NONE )
LinkLuaModifier("modifier_ravager", "modifiers/modifier_ravager", LUA_MODIFIER_MOTION_NONE)
LinkLuaModifier("modifier_duel_damage_final", "modifiers/modifier_duel_damage_final", LUA_MODIFIER_MOTION_NONE)
LinkLuaModifier("modifier_invun", "modifiers/modifier_invun", LUA_MODIFIER_MOTION_NONE)
LinkLuaModifier( "modifier_no_vision", "modifiers/modifier_no_vision", LUA_MODIFIER_MOTION_NONE )
LinkLuaModifier( "modifier_unselect", "modifiers/modifier_unselect", LUA_MODIFIER_MOTION_NONE )
LinkLuaModifier( "modifier_ward_stack", "modifiers/modifier_ward_stack", LUA_MODIFIER_MOTION_NONE )
LinkLuaModifier( "modifier_mob_thinker", "modifiers/modifier_mob_thinker", LUA_MODIFIER_MOTION_NONE )
LinkLuaModifier( "modifier_tower_incoming", "modifiers/modifier_tower_incoming", LUA_MODIFIER_MOTION_NONE )
LinkLuaModifier( "modifier_generic_attack_speed", "modifiers/generic/modifier_generic_attack_speed", LUA_MODIFIER_MOTION_NONE )
LinkLuaModifier( "modifier_generic_armor_reduction", "modifiers/generic/modifier_generic_armor_reduction", LUA_MODIFIER_MOTION_NONE )
LinkLuaModifier( "modifier_generic_silence", "modifiers/generic/modifier_generic_silence", LUA_MODIFIER_MOTION_NONE )
LinkLuaModifier( "modifier_generic_arc", "modifiers/generic/modifier_generic_arc", LUA_MODIFIER_MOTION_BOTH )
LinkLuaModifier( "modifier_generic_movespeed", "modifiers/generic/modifier_generic_movespeed", LUA_MODIFIER_MOTION_NONE )
LinkLuaModifier( "modifier_generic_knockback", "modifiers/generic/modifier_generic_knockback", LUA_MODIFIER_MOTION_BOTH )
LinkLuaModifier( "modifier_generic_taunt", "modifiers/generic/modifier_generic_taunt", LUA_MODIFIER_MOTION_NONE)
LinkLuaModifier( "modifier_generic_repair", "modifiers/generic/modifier_generic_repair", LUA_MODIFIER_MOTION_NONE )
LinkLuaModifier( "modifier_generic_break", "modifiers/generic/modifier_generic_break", LUA_MODIFIER_MOTION_NONE )
LinkLuaModifier( "modifier_generic_bkb", "modifiers/generic/modifier_generic_bkb", LUA_MODIFIER_MOTION_NONE )
LinkLuaModifier( "modifier_generic_passing", "modifiers/generic/modifier_generic_passing", LUA_MODIFIER_MOTION_NONE )
LinkLuaModifier( "modifier_no_cleave", "modifiers/generic/modifier_no_cleave", LUA_MODIFIER_MOTION_NONE )
LinkLuaModifier( "modifier_quest_blink", "modifiers/modifier_mob_thinker", LUA_MODIFIER_MOTION_NONE )
LinkLuaModifier( "modifier_start_stun", "modifiers/modifier_start_stun", LUA_MODIFIER_MOTION_NONE )
LinkLuaModifier( "modifier_contract_speed", "abilities/items/item_contract", LUA_MODIFIER_MOTION_NONE)
LinkLuaModifier( "modifier_voice_module", "modifiers/modifier_voice_module", LUA_MODIFIER_MOTION_NONE)
LinkLuaModifier( "modifier_cooldown_speed", "modifiers/modifier_cooldown_speed", LUA_MODIFIER_MOTION_NONE)
LinkLuaModifier( "modifier_percent_stats", "modifiers/modifier_percent_stats", LUA_MODIFIER_MOTION_NONE)

LinkLuaModifier( "modifier_portrait_donate_custom", "modifiers/hero_items/modifier_portrait_donate_custom", LUA_MODIFIER_MOTION_NONE )

LinkLuaModifier( "modifier_duel_field_thinker", "modifiers/modifier_duel_logic", LUA_MODIFIER_MOTION_NONE )
LinkLuaModifier( "modifier_duel_hero_thinker", "modifiers/modifier_duel_logic", LUA_MODIFIER_MOTION_NONE )
LinkLuaModifier( "modifier_duel_hero_teleport", "modifiers/modifier_duel_logic", LUA_MODIFIER_MOTION_NONE)

LinkLuaModifier( "modifier_watcher_custom", "modifiers/modifier_watcher_custom", LUA_MODIFIER_MOTION_NONE )
LinkLuaModifier( "modifier_haste_zone_thinker", "modifiers/modifier_haste_zone_thinker", LUA_MODIFIER_MOTION_NONE )
LinkLuaModifier( "modifier_duel_vision_thinker", "modifiers/modifier_duel_vision_thinker", LUA_MODIFIER_MOTION_NONE )

LinkLuaModifier("modifier_mid_teleport", "modifiers/modifier_mid_teleport", LUA_MODIFIER_MOTION_NONE)

LinkLuaModifier("modifier_tower_pre_game", "modifiers/modifier_tower_pre_game", LUA_MODIFIER_MOTION_NONE)

LinkLuaModifier("modifier_generic_debuff_immune", "modifiers/generic/modifier_generic_debuff_immune", LUA_MODIFIER_MOTION_NONE)
LinkLuaModifier("modifier_generic_bkb_visual", "modifiers/generic/modifier_generic_bkb_visual", LUA_MODIFIER_MOTION_NONE)

LinkLuaModifier("modifier_muerta_creep", "modifiers/modifier_muerta_creep", LUA_MODIFIER_MOTION_NONE)

LinkLuaModifier( "modifier_test_hero_custom", "modifiers/modifier_test_mode", LUA_MODIFIER_MOTION_NONE )


LinkLuaModifier( "modifier_recipe_gold_assault", "upgrade/general/modifier_recipe_gold_assault", LUA_MODIFIER_MOTION_NONE )
LinkLuaModifier( "modifier_recipe_gold_bfury", "upgrade/general/modifier_recipe_gold_bfury", LUA_MODIFIER_MOTION_NONE )
LinkLuaModifier( "modifier_recipe_gold_daedalus", "upgrade/general/modifier_recipe_gold_daedalus", LUA_MODIFIER_MOTION_NONE )
LinkLuaModifier( "modifier_recipe_gold_skadi", "upgrade/general/modifier_recipe_gold_skadi", LUA_MODIFIER_MOTION_NONE )
LinkLuaModifier( "modifier_recipe_gold_heart", "upgrade/general/modifier_recipe_gold_heart", LUA_MODIFIER_MOTION_NONE )
LinkLuaModifier( "modifier_recipe_gold_octarine", "upgrade/general/modifier_recipe_gold_octarine", LUA_MODIFIER_MOTION_NONE )






-- on both server and client
require("util/safeguards")



require("events_protector")
if IsClient() then
    require("function_client")
end


_G.PlayerCount = 0

_G.teleports = {}
_G.waves = {}
_G.boss_waves = {}
_G.players = {}
_G.towers = {}
_G.timer = 0
_G.Deaths = 0

Rating_Table = {40,30,10,-10,-30,-40}
Rating_Table_Max = {20,15,5,-5,-15,-20}

_G.Wave_boss_number = {5,22}
_G.Purple_Wave = {3,10}
_G.upgrade_orange = 18

_G.Deaths_Players = {}
_G.End_net = {}

_G.Time_to_pick_Hero = 25
_G.Time_to_pick_Base = 15

_G.PreGame_time = 15

_G.game_start = false
_G.Game_end = false
	
_G.new_round = false

_G.duel_start = 5


_G.duel_timer = 90
_G.round_timer = 5
_G.duel_timer_final = 80 + duel_start
_G.duel_timer_normal = 45 + duel_start
_G.field_stun = 0.5
_G.duel_necro_time = 20
_G.duel_push_time = 10
_G.duel_push_teleport = 6
_G.duel_start_wave = 12
_G.duel_last_field = "1"



_G.Target_start_wave = 7
_G.Target_end_wave = 13
_G.Target_cooldown = 3
_G.Target_gold_min = 0
_G.Target_gold = 1.2
_G.Target_gold_reward = 0.35
_G.Target_radius = 1500

_G.Streak_k = 0.25

_G.Active_Roshan = false
_G.RoshanTimers = {1260,1800,2400,3000,3600,4200,4800,5400,6000,6600,7200,7800,8400,9000,9600,10200,10800,11400,12000,12600,13200,13800,14400,15000,15600,16200,16800,17400,18000,18600,19200,19800,20400,21000,21600,22200,22800,23400,24000,24600,25200,25800,26400,27000,27600,28200,28800,29400,30000,30600,31200,31800,32400,33000,33600,34200,34800,35400,36000,36600,37200,37800,38400,39000,39600,40200,40800,41400,42000,42600,43200,43800,44400,45000,45600,46200,46800,47400,48000,48600,49200,49800,50400,51000,51600,52200,52800,53400,54000,54600,55200,55800,56400,57000,57600,58200,58800,59400,60000,60600,61200}
_G.roshan_number = 1
_G.roshan_timer = 1
_G.roshan_alert = 60



_G.patrol_timer = 0
_G.patrol_timer_max = 45
_G.patrol_timer_max_2 = 55
_G.patrol_wave = 5
_G.patrol_wave_2 = 13
_G.patrol_second_tier = 1310
_G.patrol_first_tier = 340
_G.patrol_second_init = false 
_G.patrol_first_init = false
my_game.patrol_dontgo_radiant = false
my_game.patrol_dontgo_dire = false
my_game.ravager_table = {}
my_game.ravager_max = 12

_G.give_all_vision_time = 1500
_G.init_vision = false

_G.avg_rating = 0
_G.lobby_rating = {}
_G.lobby_rating_change = {}
_G.lobby_double_rating = {}

_G.Observer_max = 4
_G.Observer_cd = 180
_G.Observer_duration = 480

_G.DeathTimer = 2
_G.StartDeathTimer = 5
_G.DeathTimer_PerWave = 2
_G.Short_Respawn = 5
_G.Short_Respawn_target = 10

_G.lownet_gold = 1
_G.lownet_purple = 2
_G.lownet_blue = 2
_G.lownet_duration = 180


_G.teleport_cd = 20
_G.teleport_range = 350

_G.UpgradeGray = 0.2
_G.BlueMorePoints = 0.25

_G.GoldComeback = 3
_G.MaxTimer = 0

_G.StartPurple = 2
_G.PlusPurple = 1

_G.auto_pick_talent = 120

_G.low_net_gold = {500, 750, 1000}
_G.low_net_current = 0
_G.low_net_waves = {[RandomInt(8, 9)] = true, [RandomInt(10, 11)] = true, [12 + RandomInt(0,1)*2] = true,}
_G.low_net_diff = 0


_G.StartBlue = 60
_G.PlusBlue = 15

_G.Necro_Timer = 20

_G.PortalDelay = 5
_G.NeutralChance = 12
_G.MaxNeutral = 4

_G.dont_end_pick_hero = false

_G.dont_end_game = false

_G.test = false-- КЛЮЧ
_G.tower = false
_G.healing = true

_G.enable_pause = false

_G.start_wave = 0
_G.timer_test = 60111
_G.timer_test_start = 101111
_G.test_wave = 0

_G.push_timer = 900
_G.push_alert = false

_G.PushReduce_duration = 5

_G.DontUpgradeCreeps = false

_G.Pause_Time = 30

_G.Trap_Duration = 35

_G.ValidGame_Time = 900

_G.kill_net_gold = 200
_G.more_gold_radius = 900

_G.bounty_timer = 0
_G.bounty_max_timer = 120
_G.bounty_init = false 
_G.bounty_start = 120
_G.bounty_gold_init = 100
_G.bounty_gold_per_minute = 4.2
_G.bounty_exp_init = 150
_G.bounty_exp_per_minute = 6
_G.bounty_blue_init = 20
_G.bounty_blue_per_minute = 0.7

_G.muerta_quest_max = 30
_G.muerta_quest_max_start = 20
_G.muerta_quest_timer = 0
_G.muerta_quest_phase = 0
_G.muerta_quest_active = false
_G.muerta_quest_hero = nil
_G.muerta_quest_creep_count = 1
_G.muerta_quest_creeps = {"npc_muerta_ogre", "npc_muerta_satyr", "npc_muerta_ursa", "npc_muerta_centaur"}


_G.Grenade_Creeps_Max = 6
_G.Grenade_Max = 4
_G.Grenade_Timer = 1200
_G.Grenade_start = false

_G.Player_damage_max = 4
_G.Player_damage_inc = 10
_G.Player_damage_time = 900

_G.LowPriorityTime = 600
_G.SafeToLeave = false
_G.SafeToLeave_reason = 0
_G.SafeToLeave_alert = false

_G.DoubleRating_timer = 25
_G.DoubleRating_active = true

_G.PartyTable = {}

_G.After_Lich = false

_G.ACT_DOTA_SPAWN_STATUE = ACT_DOTA_SPAWN_STATUE or 1766

_G.No_end_screen = {}


_G.RATING_CHANGE_BASE = { 40, 30, 10, -10, -30, -40,}

_G.glyph_cd = 360
_G.glyph_cd_mid = 240
_G.glyph_duration = 5

_G.sub_places_points = {14,12,10,8,6,4}
_G.sub_random_inc = 1.15
_G.sub_kills_inc = 1
_G.sub_kills_max = 10
_G.sub_towers_inc = 4
_G.sub_bounty_inc = 0.5
_G.sub_bounty_max = 10
_G.sub_points_max = 500
_G.sub_level_thresh =  {50,60,70,80, 100,120,140,160,180,200, 230,260,290,320,350,380, 420,460,500,540,580,620,680, 800,900,1000,1100,1200, 1500}
_G.sub_place_exp = {40,30,25,20,15,10}
_G.sub_level_max = 30
_G.level_thresh = {6,12,18,25,30}


_G.shop_daily_shards_min = 10
_G.shop_daily_shards_max = 30
_G.shop_daily_shards_cd = 86400
_G.shop_double_rating_cd = 86400 * 3
_G.shop_free_vote_cd = 86400
_G.shop_quests_cd = 86400 * 7


_G.TestMode = false
_G.TestMode_players = 2
_G.TimerStop = false
_G.WtfMode = false

_G.abandon_players = {}

_G.wrong_map_players = {}

_G.damage_table = {}


my_game.KillCount = 0

function RegisterAnimations()
    local function Reg(hname)
        RegisterCustomAnimationScriptForModel(
            string.format("models/heroes/%s/%s.vmdl", hname, hname),
            string.format("animation/%s.lua", hname)
        )
    end

end


_G.Not_spell_damage = 
{
	["templar_assassin_psi_blades_custom"] = true,
}


_G.start_abilities =
{
	"ogre_magi_dumb_luck_custom",

}

_G.ChangeItemsCooldown = 5
_G.new_shop_heroes = 
{
	"npc_dota_hero_razor",
	"npc_dota_hero_nevermore",
	"npc_dota_hero_legion_commander"
}


_G.rating_thresh =
{
	["ranked_0-500_start"] =
	{
		['min'] = 0,
		['max'] = 500,
	},
	["ranked_500-800"] = 
	{
		['min'] = 500,
		['max'] = 800,
	},
	["ranked_800-1200"] = 
	{
		['min'] = 800,
		['max'] = 1200,
	},
	["ranked_1200-x"] = 
	{
		['min'] = 1200,
		['max'] = 99999,
	},
}

_G.ranked_tier =
{
	0,150,300,500,750,1000,1300,9999999
}


local vision_abs = 
{
	{},
	{-6397,-6454,87,800,-7146,-7179,95,1000},
	{6599,6542,95,800,7371,7247,103,1000},
	{},
	{},
	{-6299,2554,103,800,-6263,3740,95,800},
	{2638,-6457,95,800,3824,-6486,103,800},
	{-2388,6400,103,800,-3574,6389,95,800},
	{6526,-2523,95,800,6529,-3710,103,800},

}


_G.NonRecordItems = 
{
	["item_clarity"] = true,
	["item_faerie_fire"] = true,
	["item_smoke_of_deceit"] = true,
	["item_ward_observer"] = true,
	["item_ward_sentry"] = true,
	["item_enchanted_mango"] = true,
	["item_flask"] = true,
	["item_tango"] = true,
	["item_blood_grenade"] = true,
	["item_dust"] = true,
	["item_bottle"] = true,
	["item_purple_upgrade_shop"] = true,
	["item_patrol_trap"] = true,
	["item_branches"] = true,
	["item_gauntlets"] = true,
	["item_slippers"] = true,
	["item_mantle"] = true,
	["item_circlet"] = true,
	["item_belt_of_strength"] = true,
	["item_boots_of_elves"] = true,
	["item_robe"] = true,
	["item_crown"] = true,
	["item_ogre_axe"] = true,
	["item_blade_of_alacrity"] = true,
	["item_staff_of_wizardry"] = true,
	["item_diadem"] = true,
	["item_ring_of_protection"] = true,
	["item_infused_raindrop"] = true,
	["item_blades_of_attack"] = true,
	["item_gloves"] = true,
	["item_chainmail"] = true,
	["item_quarterstaff"] = true,
	["item_helm_of_iron_will"] = true,
	["item_broadsword"] = true,
	["item_blitz_knuckles"] = true,
	["item_javelin"] = true,
	["item_claymore"] = true,
	["item_mithril_hammer"] = true,
	["item_ring_of_regen"] = true,
	["item_sobi_mask"] = true,
	["item_fluffy_hat"] = true,
	["item_wind_lace"] = true,
	["item_cloak"] = true,
	["item_boots"] = true,
	["item_lifesteal"] = true,
	["item_voodoo_mask"] = true,
	["item_magic_stick"] = true,
	["item_buckler"] = true,
	["item_ring_of_basilius"] = true,
	["item_headdress"] = true,
	["item_ring_of_health"] = true,
	["item_void_stone"] = true,
	["item_cornucopia"] = true,
	["item_energy_booster"] = true,
	["item_vitality_booster"] = true,
	["item_point_booster"] = true,
	["item_talisman_of_evasion"] = true,
	["item_platemail"] = true,
	["item_hyperstone"] = true,
	["item_ultimate_orb"] = true,
	["item_demon_edge"] = true,
	["item_mystic_staff"] = true,
	["item_reaver"] = true,
	["item_eagle"] = true,
	["item_relic"] = true,
	["item_patrol_warp_amulet"] = true,
	["item_contract"] = true,
	["item_patrol_restrained_orb"] = true,
	["item_patrol_midas"] = true,
	["item_patrol_vision"] = true,
	["item_roshan_necro"] = true,
	["item_patrol_fortifier"] = true,
	["item_patrol_respawn"] = true,
	["item_patrol_razor"] = true,
	["item_gray_upgrade"] = true,
	["item_ultimate_scepter"] = true,
}








_G.duel_alert_init = false
_G.duel_alert_timer = 25
_G.duel_data = {}

_G.duel_fields = 
{
    ['1'] = 
    {
        ['start1'] = Vector(6365, -7297, 104),
        ['start2'] = Vector(7511, -6220, 104),
        ['Xmax'] = 7980,
        ['Xmin'] = 5922,
        ['Ymax'] = -5759,
        ['Ymin'] = -7814,
        ['z'] = 166,
    },
    ['2'] = 
    {
        ['start1'] = Vector(-7212, 6201, 104),
        ['start2'] = Vector(-6112, 7286, 104),
        ['Xmax'] = -5652,
        ['Xmin'] = -7647,
        ['Ymax'] = 7813,
        ['Ymin'] = 5781,
        ['z'] = 166,
    },
    ['6'] = 
    {
        ['start1'] = Vector(-6242, 2429, 104),
        ['start2'] = Vector(-6242, 3899, 104),
        ['Xmax'] = -5546,
        ['Xmin'] = -6946,
        ['Ymax'] = 4249,
        ['Ymin'] = 2079,
        ['z'] = 96,
    },
    ['7'] = 
    {
        ['start1'] = Vector(2586, -6400, 96),
        ['start2'] = Vector(4046, -6400, 96),
        ['Xmax'] = 4396,
        ['Xmin'] = 2226,
        ['Ymax'] = -5700,
        ['Ymin'] = -7100,
        ['z'] = 96,
    },
    ['8'] = 
    {
        ['start1'] = Vector(-3741, 6368, 104),
        ['start2'] = Vector(-2271, 6368, 104),
        ['Xmax'] = -1921,
        ['Xmin'] = -4091,
        ['Ymax'] = 7118,
        ['Ymin'] = 5718,
        ['z'] = 96,
    },
    ['9'] = 
    {
        ['start1'] = Vector(6559, -2419, 104),
        ['start2'] = Vector(6559, -3908, 104),
        ['Xmax'] = 7259,
        ['Xmin'] = 5859,
        ['Ymax'] = -2069,
        ['Ymin'] = -4258,
        ['z'] = 96,
    },
}




_G.wall_points =
{
	['7'] = 
	{
		[1] = {2025.97, -5998.23, 2025.97, -6868.48},
		[2] = {694.821, -7259, 296.336, -6879.3},
		[3] = {347.44, -5955.41, 739.645, -5579.22}
	},
	['2'] =
	{
		[1] = {-4790.61, -6228.27, -4390.61, -5839.96},
		[2] = {-4386.9, -4969.1, -4791.75, -4553.28},
		[3] = {-5657.16, -4549.78, -6077.51, -4978.99},
		[4] = {-6076.5, -5820.35, -5672.04, -6203.93},
	},
	['6'] = 
	{
		[1] = {-5398.15, 561.633, -5806.26, 153.704},
		[2] = {-6692.4, 162.416, -7124.17, 573.562},
		[3] = {-6684.28, 1826.74, -5807.56, 1826.74}
	},
	['8'] = 
	{
		[1] = {-1705.89, 6873.77, -1705.89, 5906.28},
		[2] = {-452.015, 5550.84, -56.8497, 5947.8},
		[3] = {-56.8497, 6833.42, -407.981, 7232.22}
	},
	['3'] = 
	{
		[1] = {4666.34, 4938.2, 5090.61, 4521.21},
		[2] = {5926.45, 4549.92, 6340.09, 4933.79},
		[3] = {6349.83, 5774.71, 5910.17, 6214.89},
		[4] = {5127.78, 6216.08, 4699.64, 5787.46},
	},
	['9'] = 
	{
		[1] = {5677.74, -609.471, 6157.36, -147.471},
		[2] = {6981.28, -174.853, 7402.69, -611.983},
		[3] = {7022.56, -1848.37, 6054.74, -1848.28},
	},
}








_G.UnvalidAbilities = 
{
	["mid_teleport"] = true,
	["custom_ability_observer"] = true,
	["custom_ability_sentry"] = true,
	["custom_ability_smoke"] = true,
	["custom_ability_dust"] = true,
	["custom_ability_grenade"] = true,
	["invoker_exort_custom"] = true,
	["invoker_wex_custom"] = true,
	["invoker_quas_custom"] = true,
	["invoker_invoke_custom"] = true,
}

_G.UnvalidItems = 
{
	["item_soul_ring"] = true,
	["item_bracer_custom"] = true,
	["item_wraith_band_custom"] = true,
	["item_null_talisman_custom"] = true,
	["item_power_treads"] = true,
	["item_phase_boots"] = true,
	["item_branches"] = true,
	["item_quelling_blade"] = true,
	["item_radiance_custom"] = true,
	["item_bfury"] = true,
	["item_vambrace"] = true,	
	["item_havoc_hammer"] = true,
	["item_moon_shard"] = true,
}


_G.NoCdItems = 
{
	["item_aeon_disk"] = true,
	["item_midas_custom"] = true,
	["item_phylactery_custom"] = true,
	["item_manaflare_lens_custom"] = true,
	["item_ultimate_scepter"] = true,
	["item_tranquil_boots_custom"] = true,
	["item_falcon_blade_custom"] = true,
}

_G.custom_voice = 
{
	["npc_dota_hero_juggernaut"] = true,
	["npc_dota_hero_phantom_assassin"] = true,
	["npc_dota_hero_legion_commander"] = true,
	["npc_dota_hero_nevermore"] = true,
	["npc_dota_hero_razor"] = true
}


_G.all_heroes = 
{
	"npc_dota_hero_juggernaut",
	"npc_dota_hero_phantom_assassin",
	"npc_dota_hero_huskar",
	"npc_dota_hero_nevermore",
	"npc_dota_hero_queenofpain",
	"npc_dota_hero_legion_commander",
	"npc_dota_hero_bristleback",
	"npc_dota_hero_terrorblade",
	"npc_dota_hero_puck",
	"npc_dota_hero_void_spirit",
	"npc_dota_hero_ember_spirit",
	"npc_dota_hero_pudge",
	"npc_dota_hero_hoodwink",
	"npc_dota_hero_skeleton_king",
	"npc_dota_hero_lina",
	"npc_dota_hero_troll_warlord",
	"npc_dota_hero_axe",
	"npc_dota_hero_alchemist",
	"npc_dota_hero_ogre_magi",
	"npc_dota_hero_antimage",
	"npc_dota_hero_primal_beast",
	"npc_dota_hero_marci",
	"npc_dota_hero_templar_assassin",
	"npc_dota_hero_bloodseeker",
	"npc_dota_hero_monkey_king",
	"npc_dota_hero_mars",
	"npc_dota_hero_zuus",
	"npc_dota_hero_leshrac",
	"npc_dota_hero_crystal_maiden",
	"npc_dota_hero_snapfire",
	"npc_dota_hero_sven",
	"npc_dota_hero_sniper",
	"npc_dota_hero_muerta",
	"npc_dota_hero_pangolier",
	"npc_dota_hero_arc_warden",
	"npc_dota_hero_invoker",
	"npc_dota_hero_razor",
	"npc_dota_hero_sand_king"

}

require( 'chat_wheel')
require( 'resources')
require( 'server')
require( 'function')
require( 'timers')
require( 'spawn' )
require( 'upgrade')
require( 'debug_')
require( 'hero_select')
require( 'vector_target')
require( 'patrol_main')
require( 'shop')
require( 'talents_values')
require( 'addon_init')
require( 'test_mode')
require( 'rival_table' )

find_behavior={data32={}}
for i=1,32 do
    find_behavior.data32[i]=2^(32-i)
end

function find_behavior:d2b(arg)
    local   tr={}
    for i=1,32 do
        if arg >= self.data32[i] then
        tr[i]=1
        arg=arg-self.data32[i]
        else
        tr[i]=0
        end
    end
    return   tr
end   --bit:d2b

function find_behavior:b2d(arg)
    local   nr=0
    for i=1,32 do
        if arg[i] ==1 then
        nr=nr+2^(32-i)
        end
    end
    return  nr
end 



function find_behavior:_and(a,b)
    local   op1=self:d2b(a)
    local   op2=self:d2b(b)
    local   r={}
    
    for i=1,32 do
        if op1[i]==1 and op2[i]==1  then
            r[i]=1
        else
            r[i]=0
        end
    end
    return  self:b2d(r)
    
end


function my_game:ContainsValue(sum,nValue)
  
  if type(sum) == "userdata" then
     sum = tonumber(tostring(sum))
  end

  if find_behavior:_and(sum,nValue)==nValue then
        return true
  else
        return false
  end

end






_G.precache_items = require("precache_items")
_G.precache_units = require("precache_units")


function Precache( context )
local heroes = LoadKeyValues("scripts/npc/dota_heroes.txt")
for k,v in pairs(heroes) do
    PrecacheResource( "soundfile", "soundevents/game_sounds_heroes/game_sounds_" .. k:gsub('npc_dota_hero_','') ..".vsndevts", context )  
    PrecacheResource( "soundfile", "soundevents/voscripts/game_sounds_vo_" .. k:gsub('npc_dota_hero_','') ..".vsndevts", context ) 
end



for _,v in pairs(my_game.Particles) do
	PrecacheResource( "particle", v, context )
end

PrecacheResource( "model", "custom/item_blue.vmdl", context )  
PrecacheResource( "model", "custom/item_orange.vmdl", context )     
PrecacheResource( "model", "custom/item_gray.vmdl", context )          
PrecacheResource( "model", "custom/item_purple.vmdl", context )   
PrecacheResource( "model", "models/heroes/terrorblade/demon.vmdl", context )     
PrecacheResource( "model", "models/heroes/shadow_fiend/shadow_fiend_arcana.vmdl", context )   


for _,v in pairs(precache_items) do
	PrecacheItemByNameSync(v, context)
end

for _,v in pairs(precache_units) do
	PrecacheUnitByNameSync(v, context, -1)
end

PrecacheResource( "model", "models/items/razor/razor_arcana/razor_arcana.vmdl", context ) 


PrecacheResource( "soundfile", "soundevents/phantom_assassin_vo_custom.vsndevts", context ) 
PrecacheResource( "soundfile", "soundevents/juggernaut_vo_custom.vsndevts", context ) 
PrecacheResource( "soundfile", "soundevents/legion_commander_vo_custom.vsndevts", context ) 
PrecacheResource( "soundfile", "soundevents/nevermore_vo_custom.vsndevts", context ) 
PrecacheResource( "soundfile", "soundevents/razor_vo_custom.vsndevts", context ) 

PrecacheResource( "soundfile", "soundevents/npc_dota_hero_juggernaut.vsndevts", context ) 
PrecacheResource( "soundfile", "soundevents/npc_dota_hero_bloodseeker.vsndevts", context ) 
PrecacheResource( "soundfile", "soundevents/npc_dota_hero_razor.vsndevts", context ) 
PrecacheResource( "soundfile", "soundevents/npc_dota_hero_nevermore.vsndevts", context ) 
PrecacheResource( "soundfile", "soundevents/npc_dota_hero_antimage.vsndevts", context ) 
PrecacheResource( "soundfile", "soundevents/npc_dota_hero_axe.vsndevts", context ) 
PrecacheResource( "soundfile", "soundevents/npc_dota_hero_alchemist.vsndevts", context ) 
PrecacheResource( "soundfile", "soundevents/npc_dota_hero_phantom_assassin.vsndevts", context ) 
PrecacheResource( "soundfile", "soundevents/npc_dota_hero_arc_warden.vsndevts", context ) 
PrecacheResource( "soundfile", "soundevents/npc_dota_hero_pangolier.vsndevts", context ) 
PrecacheResource( "soundfile", "soundevents/npc_dota_hero_troll_warlord.vsndevts", context ) 
PrecacheResource( "soundfile", "soundevents/npc_dota_hero_void_spirit.vsndevts", context ) 
PrecacheResource( "soundfile", "soundevents/npc_dota_hero_skeleton_king.vsndevts", context ) 
PrecacheResource( "soundfile", "soundevents/npc_dota_hero_invoker.vsndevts", context ) 
PrecacheResource( "soundfile", "soundevents/npc_dota_hero_razor.vsndevts", context ) 
PrecacheResource( "soundfile", "soundevents/npc_dota_hero_sand_king.vsndevts", context ) 
PrecacheResource( "soundfile", "soundevents/npc_dota_hero_zuus.vsndevts", context ) 
PrecacheResource( "soundfile", "soundevents/npc_dota_hero_legion_commander.vsndevts", context ) 
PrecacheResource( "soundfile", "soundevents/vo_chat_wheel.vsndevts", context ) 

PrecacheResource( "soundfile", "endsoundevents/game_sounds.vsndevts", context )
PrecacheResource( "soundfile", "soundevents/soundevents_dota.vsndevts", context )
PrecacheResource( "soundfile", "soundevents/voscripts/game_sounds_vo_announcer.vsndevts", context )
PrecacheResource( "soundfile", "soundevents/game_sounds_effects.vsndevts", context ) 
PrecacheResource( "soundfile", "soundevents/game_sounds_ui_imported.vsndevts", context ) 
     
end


function my_game:PrecacheShopItems(name, context)

local precache_this_units = require("donate_items/"..name)
for _, info in pairs(precache_this_units) do


    if info["HeroModel"] ~= nil then
        PrecacheResource( "model", info["HeroModel"], context )
    end

    if info["ParticlesItems"] ~= nil then
        for __, info_part in pairs(info["ParticlesItems"]) do
            PrecacheResource( "particle", info_part["ParticleName"], context )
        end
    end
    if info["ParticlesHero"] ~= nil then
        for __, info_part in pairs(info["ParticlesHero"]) do
            PrecacheResource( "particle", info_part["ParticleName"], context )
        end
    end
end

local precache_slots = require("donate_items/"..name.."_slots")

for _, info in pairs(precache_slots) do
	for _,name in pairs(info) do 
        PrecacheResource( "model", name, context )
	end 
end

end 


-- Create the game mode when we activate
function Activate()

    ListenToGameEvent( "player_disconnect", Dynamic_Wrap( hero_select, 'OnDisconnect' ), hero_select )
	my_game:InitGameMode()
	HTTP.FillOfflineServerData()
end

function shuffle(x)
    for i = #x, 2, -1 do
        local j = math.random(i)
        x[i], x[j] = x[j], x[i]
    end
end

local AvailableTeams = {
    DOTA_TEAM_GOODGUYS,
    DOTA_TEAM_BADGUYS,
    DOTA_TEAM_CUSTOM_1,
    DOTA_TEAM_CUSTOM_2,
    DOTA_TEAM_CUSTOM_3,
    DOTA_TEAM_CUSTOM_4,
}

local team_size = 1





function my_game:PostMatchPoints(player)
if not IsServer() then return end
if not HTTP.IsValidGame(PlayerCount) then return end


local id = player:GetPlayerOwnerID()
local player_array = players[player:GetTeamNumber()]

if not player_array then return end

local kills = player_array.kills_done
local towers = player_array.towers_destroyed
local runes = player_array.bounty_runes_picked

local place = HTTP.playersData[id].place
local table_data = CustomNetTables:GetTableValue("sub_data", tostring(id))

if not table_data then return end

local quest_shards = 0
local quest_exp = 0

if (player:GetQuest() ~= nil) and player:QuestCompleted() and place < 4 then 
	quest_exp = player.quest.exp and player.quest.exp or 0
	quest_shards = player.quest.shards and player.quest.shards or 0
end



local random_k = 1
if player_array.randomed == 1 then 
	random_k = sub_random_inc
end




local points =  math.min(kills*sub_kills_inc, sub_kills_max) + sub_places_points[place] + towers*sub_towers_inc + math.floor(math.min(runes*sub_bounty_inc, sub_bounty_max))

points = math.floor(points * random_k)

if table_data.subscribed == 0 then 
	points = math.min(math.max(sub_points_max - table_data.points, 0), points)
end

if GameRules:GetDOTATime(false, false) < push_timer then 
	points = 0
end



HTTP.AddPlayerMatchShardsReceipt( id, points, 'endGame')
HTTP.AddPlayerMatchShardsReceipt( id, quest_shards, 'questCompleted')

points = points + quest_shards


table_data.points = table_data.points + points


local level = table_data.heroes_data[player:GetUnitName()].level
local exp = table_data.heroes_data[player:GetUnitName()].exp


if table_data.subscribed == 1 and level < sub_level_max then 

	local max_exp = sub_level_thresh[level]
	local exp_inc = math.floor(sub_place_exp[place]*random_k)

	if GameRules:GetDOTATime(false, false) < push_timer then 
		exp_inc = 0
	end

	HTTP.playersData[id].dpHeroMatchXp = exp_inc
	HTTP.playersData[id].dpHeroQuestXp = quest_exp

	exp_inc = exp_inc + quest_exp


	local exp_left = exp_inc

	repeat 
		
		if (level < 30) then 

			max_exp = sub_level_thresh[level]

			if (exp_left >= (max_exp - exp)) then 
			
				exp_left = exp_left -(max_exp - exp)
				level = level + 1
				exp = 0
			else 
		
				exp = exp + exp_left
				exp_left = 0
			end
		else 
		
			exp_left = 0
			exp = 0
		end

	until exp_left < 1


	table_data.heroes_data[player:GetUnitName()].exp = exp 
	table_data.heroes_data[player:GetUnitName()].level = level
end


CustomNetTables:SetTableValue("sub_data", tostring(id), table_data)

end





function my_game:ChangeGrenadeCount(unit, count)
if not IsServer() then return end
if true then return end

local player = players[unit:GetTeamNumber()]

if not player then return end

if count < 0 then 
	player.grenade_count = math.max(0, player.grenade_count - 1)
else 

	if player.grenade_count < Grenade_Max then
		player.grenade_count = player.grenade_count + 1

 		local item = CreateItem("item_patrol_grenade", unit, unit)

 		if unit:GetNumItemsInInventory() < 10 then
            unit:AddItem(item)
		else
		    CreateItemOnPositionSync(GetGroundPosition(unit:GetAbsOrigin(),  unit), item)
		end
	end
end

CustomGameEventManager:Send_ServerToPlayer(PlayerResource:GetPlayer(unit:GetPlayerOwnerID()), 'grenade_count_change',  {count = player.grenade_count, max = Grenade_Max, inc = count})
	
end

function my_game:InitGameMode()
	GameRules:SetCustomGameSetupAutoLaunchDelay(0)

    hero_select:RegisterHeroes()
    upgrade:InitGameMode()
    test_mode:InitGameMode()
    talents_values:InitGameMode()

    ListenToGameEvent("player_connect_full", Dynamic_Wrap(hero_select, "PlayerConnected"), hero_select)


	for _, team in pairs(AvailableTeams) do
        GameRules:SetCustomGameTeamMaxPlayers(team, team_size)
    end


    GameRules:SetSafeToLeave(true)

    GameRules:GetGameModeEntity():SetPauseEnabled( false )

    GameRules:GetGameModeEntity():SetExecuteOrderFilter( Dynamic_Wrap( my_game, "ExecuteOrderFilterCustom" ), self )


    --if test then 
    GameRules:GetGameModeEntity():SetThink( "OnThink", self, "GlobalThink", 0 )


  --	GameRules:GetGameModeEntity():SetCustomGameForceHero("npc_dota_hero_wisp")
	GameRules:GetGameModeEntity():SetGiveFreeTPOnDeath( false )
    GameRules:SetPreGameTime( 99999 )
    GameRules:GetGameModeEntity():SetDaynightCycleDisabled( false )
	--GameRules:SetTimeOfDay(0.7)
	GameRules:SetCustomGameEndDelay( 3 )
	GameRules:SetCustomVictoryMessageDuration(120)
	GameRules:SetPostGameTime(120)
	GameRules:SetTreeRegrowTime(4)

	--GameRules:GetGameModeEntity():SetCustomBuybackCooldownEnabled(true)
	GameRules:GetGameModeEntity():SetCustomBuybackCostEnabled(true)



	GameRules:GetGameModeEntity():SetCustomBackpackCooldownPercent(1)

	GameRules:GetGameModeEntity():SetTPScrollSlotItemOverride("item_tpscroll_custom")

	GameRules:GetGameModeEntity():SetAnnouncerDisabled( true )
	GameRules:GetGameModeEntity():SetAnnouncerGameModeAnnounceDisabled(true)
	GameRules:GetGameModeEntity():SetPlayerHeroAvailabilityFiltered(true)

    GameRules:SetHeroSelectionTime(9999999)
    GameRules:SetHeroSelectPenaltyTime(0)
	GameRules:SetStrategyTime(2)
	GameRules:SetShowcaseTime(0)

	GameRules:SetStartingGold(850)

	--GameRules:SetCustomGameAllowBattleMusic(true)
    --GameRules:SetCustomGameAllowHeroPickMusic(false)
   -- GameRules:SetCustomGameAllowMusicAtGameStart(false)

	GameRules:GetGameModeEntity():SetCustomGlyphCooldown(300)
    GameRules:SetUseUniversalShopMode( true )
	GameRules:GetGameModeEntity():SetDamageFilter( Dynamic_Wrap( my_game, "DamageFilter" ), self )
	GameRules:GetGameModeEntity():SetHealingFilter( Dynamic_Wrap( my_game, "HealingFilter" ), self )
	
	--GameRules:GetGameModeEntity():SetUseTurboCouriers(true)

	ListenToGameEvent( "npc_spawned", Dynamic_Wrap( self, "OnNPCSpawned" ), self )

	CustomGameEventManager:RegisterListener( "ChangeTipsType", Dynamic_Wrap(self, 'ChangeTipsType'))

	CustomGameEventManager:RegisterListener( "SelectVO", Dynamic_Wrap(chat_wheel, 'SelectVO'))
	CustomGameEventManager:RegisterListener( "SelectHeroVO", Dynamic_Wrap(chat_wheel, 'SelectHeroVO'))
	CustomGameEventManager:RegisterListener( "select_chatwheel_player", Dynamic_Wrap(chat_wheel, 'SelectChatWheel'))

    ListenToGameEvent( "game_rules_state_change", Dynamic_Wrap( self, 'OnGameRulesStateChange' ), self )

    ListenToGameEvent('dota_player_gained_level', Dynamic_Wrap(self, 'OnPlayerLevelUp'), self)

    ListenToGameEvent( "dota_glyph_used", Dynamic_Wrap( self, 'OnGlyphUsed' ), self )

    GameRules:GetGameModeEntity():SetLoseGoldOnDeath(false)


    ListenToGameEvent( "dota_item_picked_up", Dynamic_Wrap( self, "OnItemPickUp"), self )

	GameRules:GetGameModeEntity():SetBountyRunePickupFilter( Dynamic_Wrap( self, "BountyRunePickupFilter" ), self )

    CustomGameEventManager:RegisterListener( "GiveGlobalVision", Dynamic_Wrap(self, 'GiveGlobalVision'))


    CustomGameEventManager:RegisterListener( "send_report", Dynamic_Wrap(self, 'send_report'))

    CustomGameEventManager:RegisterListener( "DoubleRating", Dynamic_Wrap(self, 'DoubleRating'))

    CustomGameEventManager:RegisterListener( "request_key", Dynamic_Wrap(self, 'show_key'))
	CustomGameEventManager:RegisterListener( "shop_buy_item_player", Dynamic_Wrap(shop, 'shop_buy_item_player'))

	CustomGameEventManager:RegisterListener( "heroes_vote_change", Dynamic_Wrap(shop, 'heroes_vote_change'))
	CustomGameEventManager:RegisterListener( "heroes_vote_free", Dynamic_Wrap(shop, 'heroes_vote_free'))
	CustomGameEventManager:RegisterListener( "get_bonus_shards", Dynamic_Wrap(shop, 'get_bonus_shards'))

	CustomGameEventManager:RegisterListener( "browser_subscribe", Dynamic_Wrap(shop, 'browser_subscribe'))

   -- GameRules:GetGameModeEntity():SetModifyGoldFilter(Dynamic_Wrap(self, "GoldFilter"), self)
    GameRules:GetGameModeEntity():SetModifyExperienceFilter(Dynamic_Wrap(self, "ExpFilter"), self)
	   
	CustomGameEventManager:RegisterListener( "player_change_keybind", Dynamic_Wrap(self, 'player_change_keybind'))
	
	CustomGameEventManager:RegisterListener( "change_premium_pet", Dynamic_Wrap(shop, "ChangePetPremium"))

	CustomGameEventManager:RegisterListener( "change_show_tier", Dynamic_Wrap(shop, "ChangeShowTier"))
      
	CustomGameEventManager:RegisterListener( "end_choise_js", Dynamic_Wrap(upgrade, "EndChoiseJs"))

	CustomGameEventManager:RegisterListener( "ChangePickOrbs", Dynamic_Wrap(self, "ChangePickOrbs"))

	CustomGameEventManager:RegisterListener( "LcDuelPick", Dynamic_Wrap(self, "LcDuelPick"))

	CustomGameEventManager:RegisterListener( "dota1x6_item_change", Dynamic_Wrap(shop, 'dota1x6_item_change'))

	CustomGameEventManager:RegisterListener( "DoubleRating_show_change", Dynamic_Wrap(self, "DoubleRating_show_change"))

	CustomGameEventManager:RegisterListener( "stop_timer", Dynamic_Wrap(self, 'stop_timer'))
	CustomGameEventManager:RegisterListener( "wtf_mode", Dynamic_Wrap(self, 'wtf_mode'))

	CustomGameEventManager:RegisterListener( "SelectQuest", Dynamic_Wrap(shop, "SelectQuest"))

	CustomGameEventManager:RegisterListener( "check_id", Dynamic_Wrap(self, 'check_id'))

	CustomGameEventManager:RegisterListener( "send_cursor_position", Dynamic_Wrap(self, 'send_cursor_position'))

	if test then 
		_G.PreGame_time = 5
		_G.push_timer = 0
	end

end


function my_game:ExpFilter(params)

--print(params.experience ,' - dota')

if params.reason_const == DOTA_ModifyXP_HeroKill then 
	return false
end 

return true
end 




function my_game:CountKill()


my_game.KillCount = my_game.KillCount + 1
end 




function my_game:OnPlayerLevelUp(data)

local hero = EntIndexToHScript(data.hero_entindex)

if hero then 
	local mod = hero:FindModifierByName("modifier_voice_module")

	if mod then 
		mod:LevelEvent()
	end 
end 

end 


function my_game:stop_timer(data)
if _G.TestMode == false then return end
if data.PlayerID == nil then return end

_G.TimerStop = not _G.TimerStop


CustomGameEventManager:Send_ServerToAllClients( 'lua_timer_stop', {stop = _G.TimerStop} )
end

function my_game:wtf_mode(data)
if _G.TestMode == false then return end
if data.PlayerID == nil then return end

_G.WtfMode = not _G.WtfMode

CustomGameEventManager:Send_ServerToAllClients( 'lua_wtf_mode', {wtf = _G.WtfMode} )
end



function my_game:LcDuelPick(data)
if data.PlayerID == nil then return end

local player = PlayerResource:GetPlayer(data.PlayerID)

if not player then return end

local hero = player:GetAssignedHero()
if not hero then return end
if not hero:IsAlive() then return end

local mod = hero:FindModifierByName("modifier_duel_double_choosing")

if mod then 
	mod:EndPick(data.pick)
end 

end 




function my_game:send_cursor_position(data)
if data.PlayerID == nil then return end

local res = Vector(data.x, data.y, data.z)

local player = PlayerResource:GetPlayer(data.PlayerID)

if not player then return end

local hero = player:GetAssignedHero()
if not hero then return end

local ability = hero:FindAbilityByName("templar_assassin_trap_custom")

if ability then 

	ability:Activate(data.x, data.y, data.z)
end

end


function my_game:ActivatePushReduce(team, enemy_team, on_death, team_array)
if not towers[team] then return end

local death = 0
if on_death == 1 then 
	death = 1
end 

local target = nil


local array = {}

if team_array then 
	for _,team in pairs(team_array) do 
		if players[team] then 
			array[#array + 1] = players[team]
		end 
	end

	if #array == 0 then 
		if enemy_team and players[enemy_team] then 
			target = players[enemy_team]:entindex()
		end
	end 
else  

	if enemy_team and players[enemy_team] then 
		target = players[enemy_team]:entindex()
	end
end 

local duration = PushReduce_duration 


local base = FindUnitsInRadius( team, towers[team]:GetAbsOrigin(), nil, 2000, DOTA_UNIT_TARGET_TEAM_FRIENDLY, DOTA_UNIT_TARGET_BUILDING, DOTA_UNIT_TARGET_FLAG_INVULNERABLE, FIND_ANY_ORDER,false)
        
for _,building in pairs(base) do 

	if death == 1 then 
		building:RemoveModifierByName("modifier_tower_incoming_push_reduce")
	end 

 	local mod = building:AddNewModifier(building, nil, "modifier_tower_incoming_push_reduce", {duration = duration, hero = target, death = death})

 	if mod and #array > 0 then 
 		mod.heroes = {}

 		for _,hero in pairs(array) do 
 			mod.heroes[#mod.heroes + 1] = hero
 		end 
 	end 
end	


end



function my_game:TestQuest(hero)

if muerta_quest_phase == 1 then 
	my_game:MuertaQuestSpawnDig(hero)
end

if muerta_quest_phase == 2 then 
	my_game:MuertaQuestSpawnCreep(hero)

end

end




function my_game:MuertaQuestPhase(hero)


if hero and muerta_quest_hero == nil then 
	muerta_quest_hero = hero
end


muerta_quest_phase = muerta_quest_phase + 1

if muerta_quest_phase > 2 then 
	muerta_quest_phase = 0
end

if muerta_quest_phase == 1 then 
	muerta_quest_timer = muerta_quest_max - muerta_quest_max_start
	muerta_quest_active = true


	local count = RandomInt(1, 10) 

	for i = 1,count do 

		local random_1 = RandomInt(1, #muerta_quest_creeps)
		local random_2 = random_1

		repeat random_2 = RandomInt(1, #muerta_quest_creeps)
		until random_2 ~= random_1
	 
	 	local buffer = muerta_quest_creeps[random_1]

	 	muerta_quest_creeps[random_1] = muerta_quest_creeps[random_2]
	 	muerta_quest_creeps[random_2] = buffer

	end

end


end



function my_game:MuertaQuestSpawnDig()

local spawners = Entities:FindAllByName("muerta_dig_area")

if #spawners > 0 then 
	local abs = spawners[RandomInt(1, #spawners)]:GetAbsOrigin()

	GameRules:ExecuteTeamPing(muerta_quest_hero:GetTeamNumber(), abs.x, abs.y, muerta_quest_hero, 0 )

	local thinker = CreateUnitByName("npc_dota_companion", abs, false, nil, nil,muerta_quest_hero:GetTeamNumber())
	thinker:AddNewModifier(muerta_quest_hero, nil, "modifier_muerta_gunslinger_custom_dig_area", {}) 

	local bounty = CreateUnitByName("npc_dota_companion", abs + RandomVector(RandomInt(100, 500)), false, nil, nil,muerta_quest_hero:GetTeamNumber())
	bounty:AddNewModifier(muerta_quest_hero, nil, "modifier_muerta_gunslinger_custom_dig_bounty", {area = thinker:entindex()}) 
end

end


function my_game:MuertaQuestSpawnCreep()

local spawners = Entities:FindAllByName("muerta_creep_area")

if #spawners > 0 then 
	local abs = spawners[RandomInt(1, #spawners)]:GetAbsOrigin()

	GameRules:ExecuteTeamPing(muerta_quest_hero:GetTeamNumber(), abs.x, abs.y, muerta_quest_hero, 0 )

	local unit = CreateUnitByName(muerta_quest_creeps[muerta_quest_creep_count], abs, true, nil, nil, DOTA_TEAM_NEUTRALS)

	unit:AddNewModifier(muerta_quest_hero, nil, "modifier_muerta_creep", {})
end

muerta_quest_creep_count = muerta_quest_creep_count + 1

if muerta_quest_creep_count > #muerta_quest_creeps then 
	muerta_quest_creep_count = 1
end

end



function my_game:MuertaQuestClearArea()
if not muerta_quest_hero then return end

local units = FindUnitsInRadius( muerta_quest_hero:GetTeamNumber(), Vector(0,0,0), nil, FIND_UNITS_EVERYWHERE, DOTA_UNIT_TARGET_TEAM_BOTH, DOTA_UNIT_TARGET_ALL, DOTA_UNIT_TARGET_FLAG_INVULNERABLE + DOTA_UNIT_TARGET_FLAG_OUT_OF_WORLD, FIND_ANY_ORDER, false )

for _,unit in pairs(units) do
	if unit and not unit:IsNull() and unit:HasModifier("modifier_muerta_gunslinger_custom_dig_bounty") then 
		unit:FindModifierByName("modifier_muerta_gunslinger_custom_dig_bounty"):Complete()
	end

	if unit and not unit:IsNull() and unit:HasModifier("modifier_muerta_creep") then 
		unit:Kill(nil, nil)
	end
end


end


function my_game:MuertaQuestTimer()

if muerta_quest_phase ~= 0 and muerta_quest_hero ~= nil and players[muerta_quest_hero:GetTeamNumber()] and muerta_quest_active == true then 

	muerta_quest_timer = muerta_quest_timer + 1


	if muerta_quest_timer >= muerta_quest_max then 
		
		muerta_quest_active = false

		muerta_quest_timer = 0

		if muerta_quest_phase == 1 then 
			my_game:MuertaQuestSpawnDig()
		end

		if muerta_quest_phase == 2 then 
			my_game:MuertaQuestSpawnCreep()
		end
	end
end


end 














_G.SpawnedPlayers = 0
_G.ReadyPlayers = 0

_G.GlobalHeroes = {}


function my_game:OnNPCSpawned(event)

local unit = EntIndexToHScript(event.entindex)
local new_spawned_hero = EntIndexToHScript(event.entindex)

if new_spawned_hero and new_spawned_hero:IsHero() and new_spawned_hero.first_spawn_model == nil then
    new_spawned_hero.first_spawn_model = true
    if new_spawned_hero and new_spawned_hero:GetUnitName() == "npc_dota_hero_razor" and not new_spawned_hero:IsIllusion() then
        unit:SetModel("models/items/razor/razor_arcana/razor_arcana.vmdl")
        unit:SetOriginalModel("models/items/razor/razor_arcana/razor_arcana.vmdl")
        local has_arcana = false
        if new_spawned_hero ~= nil and new_spawned_hero:IsHero() then
            local children = new_spawned_hero:GetChildren();
            for k,child in pairs(children) do
                if child and child:GetClassname() == "dota_item_wearable" and child:GetModelName() == "models/items/razor/razor_arcana/razor_arcana_weapon.vmdl" then
                    has_arcana = true
                    break
                end
            end
        end
        local time = 0.2
        if new_spawned_hero:IsIllusion() then
            time = FrameTime()
        end
        shop:RemoveAllItemsOtherModel(unit)
        Timers:CreateTimer(time, function()
            if not has_arcana then
                new_spawned_hero:SetOriginalModel("models/heroes/razor/razor.vmdl")
                new_spawned_hero:SetModel("models/heroes/razor/razor.vmdl")
                shop:UpdateRazorParticle(new_spawned_hero, false)
            end
            shop:AddedDonateHero(new_spawned_hero, new_spawned_hero:GetPlayerOwnerID())
        end)
    else
        shop:AddedDonateHero(new_spawned_hero, new_spawned_hero:GetPlayerOwnerID())
    end
end

if unit:GetTeamNumber() == DOTA_TEAM_NEUTRALS then 

	local gold = unit:GetMinimumGoldBounty()*0.85
	local exp = (unit:GetDeathXP()*0.7)
	unit:SetMaximumGoldBounty(gold)
	unit:SetMinimumGoldBounty(gold)
	unit:SetDeathXP(exp)
end 

if SpawnedPlayers >= PlayerCount then return end



if unit and unit:IsRealHero() and (event.is_respawn == "0" or event.is_respawn == 0)  then 

	local id = unit:GetPlayerOwnerID()


	Timers:CreateTimer(0.1, function()



		if unit:HasModifier("modifier_monkey_king_wukongs_command_custom_soldier") then return end

		GlobalHeroes[id] = unit

		unit:AddNewModifier(unit, nil, "modifier_start_stun", {})

	    if unit and unit:GetUnitName() == "npc_dota_hero_monkey_king" then

	        local monkey_king_ultimate = unit:FindAbilityByName("monkey_king_wukongs_command_custom")
	           

	        if monkey_king_ultimate then
	            monkey_king_ultimate:CreateSoldiers()
	        end
	    end

	    _G.SpawnedPlayers = _G.SpawnedPlayers + 1

		my_game:initiate_player(unit, Pause_Time, SelectedHeroes[id].random)
		--shop:AddedDonateHero(unit, unit:GetPlayerOwnerID())


	    if SelectedBases[id] then

	    	my_game:PlaceHero(id)
	    end


	end)

end
	

end



function my_game:PlaceHero(id)


if PlayerResource:IsValidPlayerID(id) and PlayerResource:GetSteamAccountID(id) ~= 0 and BASE_POSITION[SelectedBases[id]] and GlobalHeroes[id] then

	local unit = GlobalHeroes[id]
	
	local position = BASE_POSITION[SelectedBases[id]]
	
	unit:SetAbsOrigin(position)
	FindClearSpaceForUnit(unit, position, true)
	unit:SetRespawnPosition(position)
	

	local team = unit:GetTeamNumber()
	
	local spawner = Entities:FindByName(nil, "spawn" .. team)
	if spawner ~= nil then
	    spawner:SetAbsOrigin(position)
	end
	
	
	local hero_name = unit:GetUnitName()
	
	
	local sub_data = CustomNetTables:GetTableValue("sub_data", tostring(id))
	
	if sub_data and sub_data.heroes_data[hero_name] and sub_data.heroes_data[hero_name].has_level == 1 and sub_data.heroes_data[hero_name].tier and sub_data.subscribed == 1 then
	
		local particle = ParticleManager:CreateParticle( "particles/hero_spawn_hero_level_"..(sub_data.heroes_data[hero_name].tier + 1)..".vpcf", PATTACH_ABSORIGIN_FOLLOW, unit )
		ParticleManager:ReleaseParticleIndex( particle )
	end
	
	PlayerResource:SetCameraTarget(id, unit)
	
	Timers:CreateTimer(0.1, function() 

		PlayerResource:SetCameraTarget(id, nil) 
		my_game:SetTower(unit)
		unit:RemoveModifierByName("modifier_start_stun")
		unit:Stop()

	end)
	
	ReadyPlayers = ReadyPlayers + 1
	

	if ReadyPlayers == PlayerCount then 

		CustomGameEventManager:Send_ServerToAllClients( 'end_loading', {} )
		CustomGameEventManager:Send_ServerToAllClients( 'PreGameEnd_top', {} ) 
	--	CustomGameEventManager:Send_ServerToAllClients( 'WaitingPlayers_end', {} ) 

		Timers:CreateTimer("", {useGameTime = false, endTime = 2,
			callback = function()
				my_game:initiate_tower()
				my_game:CheckBanStatus()
		end})
	end


end

end




        
function my_game:SetTower(unit)

local team = unit:GetTeamNumber()


local find_towers =  FindUnitsInRadius(  team,  unit:GetAbsOrigin(), nil,  3000,  DOTA_UNIT_TARGET_TEAM_BOTH,  DOTA_UNIT_TARGET_BUILDING + DOTA_UNIT_TARGET_BASIC,  DOTA_UNIT_TARGET_FLAG_INVULNERABLE, 0, false )

for _,building in ipairs(find_towers) do
	if building:IsBuilding() or building:GetUnitName() == "npc_teleport" then

		building:SetTeam(team)

		local effect_name = '' 

  		building:RemoveModifierByName("modifier_invulnerable")
  		if building:GetUnitName() == "npc_filler_radiant_resist" then
  			effect_name = "particles/radiant_resist.vpcf"
  		end
  		if building:GetUnitName() == "npc_filler_radiant_stun" then
  			effect_name = "particles/radiant_stun.vpcf"
  		end
  		if building:GetUnitName() == "npc_filler_radiant_plasma" then
  			effect_name = "particles/radiant_plasma.vpcf"
  		end


  		if building:GetUnitName() == "npc_filler_dire_resist" then
  			effect_name = "particles/dire_resist.vpcf"
  		end
  		if building:GetUnitName() == "npc_filler_dire_stun" then
  			effect_name = "particles/dire_stun.vpcf"
  		end
  		if building:GetUnitName() == "npc_filler_dire_plasma" then
  			effect_name =  "particles/world_shrine/dire_shrine_ambient.vpcf"
  		end

  		if effect_name ~= '' then 
			building.effect = ParticleManager:CreateParticle(effect_name, PATTACH_ABSORIGIN_FOLLOW, building)
			building:AddNewModifier(building, nil, "modifier_tower_incoming", {})	
		end

		if (building:GetUnitName() == "npc_towerdire" or building:GetUnitName() == "npc_towerradiant")  then
			towers[unit:GetTeamNumber()] = building	
			towers[unit:GetTeamNumber()]:AddNewModifier(building, nil, "modifier_tower_level", {})	
			towers[unit:GetTeamNumber()]:AddNewModifier(building, nil, "modifier_tower_incoming", {})
	
		end

   		if building:GetUnitName() == "npc_teleport"  then

			building:StartGesture(ACT_DOTA_IDLE)

			building:AddNewModifier(nil, nil, "modifier_mid_teleport", {})


			teleports[building:GetTeamNumber()] = building


			local number = tonumber(building:GetName())


			if number == 3 or number == 8 or number == 9 then
			  building:SetMaterialGroup("1")
			end 

			if number == 2 or number == 6 or number == 7 then
			  building:SetMaterialGroup("0")
			end 

			if number == 2 or number == 3 then 
				local mod = unit:FindModifierByName("modifier_item_custom_observer_ward_charges")

				if mod then 
					mod:IncrementStackCount()
				end

				mod = unit:FindModifierByName("modifier_item_custom_sentry_ward_charges")

				if mod then 
					mod:IncrementStackCount()
				end

				mod = unit:FindModifierByName("modifier_item_custom_smoke_charges")

				if mod then 
					mod:IncrementStackCount()
				end

			end

			local Vector_fow = Vector(vision_abs[number][1],vision_abs[number][2],vision_abs[number][3])
			AddFOWViewer(unit:GetTeamNumber(), Vector_fow, vision_abs[number][4], 99999, true)

			Vector_fow = Vector(vision_abs[number][5],vision_abs[number][6],vision_abs[number][7])
			AddFOWViewer(unit:GetTeamNumber(), Vector_fow, vision_abs[number][8], 99999, true)
		end

	end
end

if game_start == false then 
	towers[unit:GetTeamNumber()]:AddNewModifier(building, nil, "modifier_tower_pre_game", {target = unit:entindex()})	
end

end


_G.bounty_abs = {}

function my_game:PreGame()

hero_select:EndPick(true)

my_game:initiate_waves()

--CustomGameEventManager:Send_ServerToAllClients( 'WaitingPlayers_show', {} ) 

local spawners = Entities:FindAllByName("bounty_spawner")

for _,spawner in pairs(spawners) do 
	local abs = spawner:GetAbsOrigin()

	abs.z = GetGroundPosition(abs, nil).z + 50

	bounty_abs[#bounty_abs + 1] = Vector(abs.x, abs.y , abs.z)

end

local duel_vision = Entities:FindAllByName("duel_vision")

for _,vision in pairs(duel_vision) do 
	local abs = vision:GetAbsOrigin()

	CreateModifierThinker(nil, nil, "modifier_duel_vision_thinker", {}, abs, DOTA_TEAM_NEUTRALS, false)
end




local haste_zones = Entities:FindAllByName("haste_zone")

for _,zone in pairs(haste_zones) do 
	local abs = zone:GetAbsOrigin()

	CreateModifierThinker(nil, nil, "modifier_haste_zone_thinker", {}, abs, DOTA_TEAM_NEUTRALS, false)
end 

for _,watcher in pairs(Entities:FindAllByName("watcher_radiant")) do 
	watcher:AddNewModifier(watcher, nil, "modifier_watcher_custom", {material = 1})
end

for _,watcher in pairs(Entities:FindAllByName("watcher_dire")) do 
	watcher:AddNewModifier(watcher, nil, "modifier_watcher_custom", {material = 2})
end



if (IsInToolsMode() or GameRules:IsCheatMode() or not HTTP.IsValidGame(PlayerCount)) or (enable_pause) then 
	GameRules:GetGameModeEntity():SetPauseEnabled( true )
end


CreateModifierThinker(nil, nil, "modifier_mob_thinker", {}, Vector(), DOTA_TEAM_NEUTRALS, false)

GameRules:GetGameModeEntity():SetThink( spawn_timer, "spawn_timer_timer", 1 )

GameRules:GetGameModeEntity():SetThink( check_death, "check_tower_timer", 0 )


Timers:CreateTimer(1, function()

	CustomGameEventManager:Send_ServerToAllClients( 'init_hero_level', {} )
end)

CustomGameEventManager:Send_ServerToAllClients( 'init_chat', {tools = IsInToolsMode(), cheat = GameRules:IsCheatMode(), valid = HTTP.IsValidGame( PlayerCount )} )


end



function my_game:EndPickStage()


for id = 0,24 do 
	if PlayerResource:IsValidPlayerID(id) and PlayerResource:GetSteamAccountID(id) ~= 0 and GlobalHeroes[id] and towers[GlobalHeroes[id]:GetTeamNumber()] == nil then
		my_game:PlaceHero(id)
	end
end

for _,tower in pairs(towers) do
	tower:RemoveModifierByName("modifier_tower_pre_game")
end


GameRules:GetGameModeEntity():SetThink( start_game_timer, "StartGameTimer", 1 )

end

	


function start_game_timer()

_G.PreGame_time = _G.PreGame_time - 1

test_mode:InitPlayers()

CustomGameEventManager:Send_ServerToAllClients( 'PreGameStart', {time = PreGame_time} ) 

if PreGame_time == 7 then 
	CustomGameEventManager:Send_ServerToAllClients('generic_sound',  {sound = "UI.Battle_begin_sound"})
end



if PreGame_time <= 0 then 

	CustomGameEventManager:Send_ServerToAllClients('generic_sound',  {sound = "UI.Battle_begin"})
  

	CustomGameEventManager:Send_ServerToAllClients( 'PreGameEnd', {} ) 
	GameRules:ForceGameStart()
	return -1
end

return 1
end


function my_game:CheckPause()


if (game_start == true and  (not IsInToolsMode() and not GameRules:IsCheatMode() and HTTP.IsValidGame(PlayerCount)) and (not enable_pause)) then 
 
	local should_pause = false
	
	for id = 0,24 do
		if PlayerResource:IsValidPlayerID(id) and PlayerResource:GetSteamAccountID(id) ~= 0  then 
	
	
			local state = PlayerResource:GetConnectionState(id)
			local hero = GlobalHeroes[id]
	
			if hero ~= nil and players[hero:GetTeamNumber()] ~= nil then  
	
				local player = players[hero:GetTeamNumber()]
			
				--CustomGameEventManager:Send_ServerToPlayer(PlayerResource:GetPlayer(id), "pause_info_timer", {time = player.pause_time} )

				if ((player.pause_time > 0) and (state == DOTA_CONNECTION_STATE_DISCONNECTED or state == DOTA_CONNECTION_STATE_LOADING ) or
					(player.after_pause_time > 0 and state == DOTA_CONNECTION_STATE_CONNECTED))
				 	and GameRules:GetDOTATime(false, false) > 1 then
	
					should_pause = true
	
					local time = players[hero:GetTeamNumber()].pause_time
					local hero_name = players[hero:GetTeamNumber()]:GetUnitName()
					
					if (player.pause_time > 0 and (state == DOTA_CONNECTION_STATE_DISCONNECTED or state == DOTA_CONNECTION_STATE_LOADING)) then 
						CustomGameEventManager:Send_ServerToAllClients( 'pause_think', {time = time, id = id, player = SelectedHeroes[id].hero} )

						player.pause_time = player.pause_time - 1
						player.after_pause_time = 3
					end

					if (player.after_pause_time > 0 and state == DOTA_CONNECTION_STATE_CONNECTED ) then 
						CustomGameEventManager:Send_ServerToAllClients( 'pause_think', {time = player.after_pause_time, id = id, player = SelectedHeroes[id].hero} )

						player.after_pause_time = player.after_pause_time - 1

					end

				else
					CustomGameEventManager:Send_ServerToAllClients( 'pause_end', {id = id} )
				end
		
	
			end
	
		
		end
	end
	
	if GameRules:IsGamePaused() == true then 
		if should_pause == false then 
			PauseGame(false)
		end
	else 
		if should_pause == true  then 
			PauseGame(true)
		end
	end

end



end




function my_game:start_game()
if game_start then return end


game_start = true 


for _,tower in pairs(towers) do
	tower:RemoveModifierByName("modifier_tower_pre_game")
end


Timers:CreateTimer(
"",
{
	useGameTime = false,
	endTime = 0,
	callback = function()

	my_game:CheckPause()
	return 1
end})


GameRules:SpawnNeutralCreeps()
GameRules:SetTimeOfDay(0.25)

end




function my_game:CheckBanStatus()


if not HTTP.IsValidGame(PlayerCount) then 
   	Timers:CreateTimer(1, function() 
   		CustomGameEventManager:Send_ServerToAllClients( 'alert_notvalid', {} ) 
	end)	
	return 
end

local active_vote = CustomNetTables:GetTableValue("sub_data", "heroes_vote" ).active_vote

if active_vote == 1 then
    CustomGameEventManager:Send_ServerToAllClients('show_active_vote', {} ) 
elseif #new_shop_heroes > 0 then  
    CustomGameEventManager:Send_ServerToAllClients('show_new_shop_heroes', {heroes = new_shop_heroes} ) 
end 

for _,player in pairs(players) do 

	if active_vote == 0 then
		if player.islp then 
			CustomGameEventManager:Send_ServerToPlayer(PlayerResource:GetPlayer(player:GetPlayerOwnerID()), 'alert_dont_leave', {lp = 1} )
		else 
			CustomGameEventManager:Send_ServerToPlayer(PlayerResource:GetPlayer(player:GetPlayerOwnerID()), 'alert_dont_leave', {lp = 0} )
		end
	end

	local name = tostring(GetMapName())
	local server_data = CustomNetTables:GetTableValue("server_data", tostring(player:GetPlayerOwnerID()) )

	local wrong_map_status = server_data.wrong_map_status

	if wrong_map_status and wrong_map_status == 2 then 
		wrong_map_players[player:GetPlayerOwnerID()] = true
	end 


	if HTTP.serverData.isStatsMatch == true or test == true then 
		if rating_thresh[name] and wrong_map_status then 
			
			if wrong_map_status == 2 then 
				player.banned = true
				CustomGameEventManager:Send_ServerToPlayer(PlayerResource:GetPlayer(player:GetPlayerOwnerID()), 'BadMap_ban', {mmr = lobby_rating[player:GetPlayerOwnerID()], min = rating_thresh[name].min, max = rating_thresh[name].max} )
			end 

			if wrong_map_status == 1 then
				CustomGameEventManager:Send_ServerToPlayer(PlayerResource:GetPlayer(player:GetPlayerOwnerID()), 'BadMap', {mmr = lobby_rating[player:GetPlayerOwnerID()], min = rating_thresh[name].min, max = rating_thresh[name].max} )
			end
		else 
			if active_vote == 0 then
				CustomGameEventManager:Send_ServerToPlayer(PlayerResource:GetPlayer(player:GetPlayerOwnerID()), 'unranked_alert', {} )
			end
		end
		player.wrong_map_status = wrong_map_status

	end

end

check_reports() 

end





function my_game:check_id(kv)

	print(kv.PlayerID)

	print(PlayerResource:GetSteamAccountID(kv.PlayerID))
end



function my_game:DoubleRating_show_change(data)
if data.PlayerID == nil then return end


local player = players[GlobalHeroes[data.PlayerID]:GetTeamNumber()]

if not player then return end

if player.HideDouble == 1 then 
	player.HideDouble = 0
else 
	player.HideDouble = 1
end

CustomGameEventManager:Send_ServerToPlayer(PlayerResource:GetPlayer(data.PlayerID), 'DoubleRating_show_change_js', {state = player.HideDouble} ) 
end





function my_game:DoubleRating(data)
if data.PlayerID == nil then return end
if not GlobalHeroes[data.PlayerID]  then return end

local player = players[GlobalHeroes[data.PlayerID]:GetTeamNumber()]

if not player then return end


local subData = CustomNetTables:GetTableValue("sub_data", tostring(data.PlayerID))

if subData.double_rating_cd > 0 then return end

subData.double_rating_cd = shop_double_rating_cd

HTTP.DoubleRating( data.PlayerID, subData.double_rating_cd * 1000 )


local unit = GlobalHeroes[data.PlayerID]



lobby_double_rating[data.PlayerID] = true


if player.HideDouble == 0 then 
	CustomGameEventManager:Send_ServerToAllClients( 'double_rating_alert', {unit = unit:GetUnitName()} ) 
end


CustomGameEventManager:Send_ServerToPlayer(PlayerResource:GetPlayer(data.PlayerID), 'hide_double_rating', {} ) 

CustomNetTables:SetTableValue("sub_data", tostring(data.PlayerID), subData)
end



function my_game:player_change_keybind(data)
    if data.PlayerID == nil then return end
    local keybinds_table = CustomNetTables:GetTableValue("keybinds", tostring(data.PlayerID))
    if data.name == "cast_ability_sentry" then
        keybinds_table.keybind_sentry_ward = data.newKey
    elseif data.name == "cast_ability_observer" then
        keybinds_table.keybind_observer_ward = data.newKey
    elseif data.name == "cast_ability_smoke" then
        keybinds_table.keybind_smoke = data.newKey
    elseif data.name == "cast_ability_dust" then
        keybinds_table.keybind_dust = data.newKey
    elseif data.name == "cast_ability_grenade" then
        keybinds_table.keybind_grenade = data.newKey
    end
    CustomNetTables:SetTableValue("keybinds", tostring(data.PlayerID), keybinds_table)
end



function my_game:InitLowNet(unit)

CustomGameEventManager:Send_ServerToPlayer(PlayerResource:GetPlayer(unit:GetPlayerOwnerID()), "lownet_bonus", {gold = low_net_gold[low_net_current]})

Timers:CreateTimer(1, function()

	my_game:AddPurplePoints(unit, 1)
	my_game:CreateUpgradeOrb(unit, 2)
	unit:ModifyGold(low_net_gold[low_net_current], true, DOTA_ModifyGold_Unspecified)
	SendOverheadEventMessage(unit, 0, unit, low_net_gold[low_net_current], nil)


end)

end





function my_game:show_key(data)
	if data.PlayerID == nil then return end
	local steamid = PlayerResource:GetSteamID(data.PlayerID)


	if tostring(steamid) == "76561198192555753" then 

		CustomGameEventManager:Send_ServerToPlayer(PlayerResource:GetPlayer(data.PlayerID), 'print_debug',  {text = GetDedicatedServerKeyV2(data.fuck_cheaters)})
		
	end

end

 

function my_game:ChangeTipsType(data) 
	if data.PlayerID == nil then return end
	CustomNetTables:SetTableValue("TipsType", tostring(data.PlayerID), {type = data.type})
end




function my_game:BountyRunePickupFilter(params)

CustomGameEventManager:Send_ServerToPlayer(PlayerResource:GetPlayer(params.player_id_const), 'delete_bounty',  {})
				
local unit = GlobalHeroes[params.player_id_const]

if not unit then return end



local minute = math.floor(GameRules:GetDOTATime(false, false) / 60)
local gold = bounty_gold_init + minute * bounty_gold_per_minute
local blue = bounty_blue_init + minute * bounty_blue_per_minute
local exp = bounty_exp_init + minute * bounty_exp_per_minute


unit:AddExperience(exp, 5, false, false)
my_game:AddBluePoints(unit, blue)

if (players[unit:GetTeamNumber()]) then 
	players[unit:GetTeamNumber()].bounty_runes_picked = players[unit:GetTeamNumber()].bounty_runes_picked + 1
end

if (unit:GetQuest() == "General.Quest_6") then 
	unit:UpdateQuest(1)
end


if unit and unit:HasModifier("modifier_alchemist_goblins_greed_custom") then 
	local ability = unit:FindAbilityByName("alchemist_goblins_greed_custom")
	gold = gold*ability:GetSpecialValueFor("bounty_multiplier")

	if unit:HasModifier("modifier_alchemist_greed_5") then 
		ability:GiveBuff()
	end

	unit:AddNewModifier(unit, ability, "modifier_alchemist_goblins_greed_custom_runes", {})


end

local mod = unit:FindModifierByName("modifier_voice_module") 

if mod then 
	mod:BountyEvent()
end 


params["gold_bounty"] = gold 

return true

end

function my_game:send_report(kv)
    if kv.PlayerID == nil then return end

    local reported1 = PlayerResource:GetSteamAccountID(kv.Hero_1)
    local reported2 = PlayerResource:GetSteamAccountID(kv.Hero_2)

    local targets = {tostring(reported1), tostring(reported2)}

    local reports = CustomNetTables:GetTableValue("reports", tostring(kv.PlayerID))
    if reports.report == 0 then
        return
    end

    CustomNetTables:SetTableValue("reports", tostring(kv.PlayerID), {
        report = reports.report - 1    
    })

    
    HTTP.Report( kv.PlayerID, kv.Hero_1,kv.Hero_2, 0)
end



function my_game:OnGlyphUsed( params )

	local player = players[params.teamnumber]
	local cd = glyph_cd

	if player and player.Players_Died < 3 and player:IsMidPlayer() then 
		cd = glyph_cd_mid
	end

	GameRules:SetGlyphCooldown( params.teamnumber, cd )

	if players[params.teamnumber] ~= nil then 
		CustomGameEventManager:Send_ServerToAllClients( 'glyph_used', {player = players[params.teamnumber]:GetUnitName()} )
	end

	local towers = FindUnitsInRadius( params.teamnumber, Vector(0, 0, 0), nil, FIND_UNITS_EVERYWHERE, DOTA_UNIT_TARGET_TEAM_FRIENDLY, DOTA_UNIT_TARGET_BUILDING, DOTA_UNIT_TARGET_FLAG_MAGIC_IMMUNE_ENEMIES, 0, false )
	
	for _,tower in pairs(towers) do

		if tower:FindModifierByName("modifier_fountain_glyph") then 
			tower:FindModifierByName("modifier_fountain_glyph"):SetDuration(glyph_duration, true)
		end
	end

end



function my_game:ChangePickOrbs( kv )
if kv.PlayerID == nil then return end
if not GlobalHeroes[kv.PlayerID] then return end


local player = players[GlobalHeroes[kv.PlayerID]:GetTeamNumber()]

if not player then return end

if player.PickOrbs == 1 then 
	player.PickOrbs = 0
else 
	player.PickOrbs = 1
end

CustomGameEventManager:Send_ServerToPlayer( PlayerResource:GetPlayer(kv.PlayerID), "ChangePickOrbs_js", { pick = player.PickOrbs } )

end


_G.self_disarm = 
{
	["modifier_alchemist_chemical_rage_custom_legendary"] = true,
	["modifier_razor_static_link_custom_attacking"] = true
}

function my_game:CheckDisarm( unit )
if not IsServer() then return end
if unit:IsDebuffImmune() then return end

for _, mod in pairs(unit:FindAllModifiers()) do
    if not self_disarm[mod:GetName()] then
       -- if mod.CheckState then
            local tables = {}
            mod:CheckStateToTable(tables)
            for state_name, mod_table in pairs(tables) do
                if tostring(state_name) == '1'  then
                     return true
                end
            end
        --end
    end
end
return false
end





function my_game:BreakInvis( unit )
if not IsServer() then return end

local mod = {
		"modifier_item_trickster_cloak_invis",
		"modifier_invisible"

}

for _,i in ipairs(mod) do 
	if unit:HasModifier(i) then 
		unit:RemoveModifierByName(i)
	end
end

end







function my_game:GenericHeal(target, heal, ability, no_text, effect)
if not IsServer() then return end

target:Heal(heal, ability)

local part = "particles/generic_gameplay/generic_lifesteal.vpcf"

if effect then 
	part = effect
end


local particle = ParticleManager:CreateParticle( part, PATTACH_ABSORIGIN_FOLLOW, target )
ParticleManager:ReleaseParticleIndex( particle )


if no_text and no_text == true then return end

SendOverheadEventMessage(target, 10, target, heal, nil)
end







_G.BluePoints = 
{
	["npc_dota_neutral_kobold"] = 2,
	["npc_dota_neutral_kobold_tunneler"] = 2,

	["npc_dota_neutral_kobold_taskmaster"] = 6, 

	["npc_dota_neutral_forest_troll_berserker"] = 4,
	["npc_dota_neutral_forest_troll_high_priest"] = 6, 

	["npc_dota_neutral_harpy_scout"] = 4, 
	["npc_dota_neutral_harpy_storm"] = 6,

	["npc_dota_neutral_gnoll_assassin"] = 5, 

	["npc_dota_neutral_ghost"] = 6, 
	["npc_dota_neutral_fel_beast"] = 4, 



	["npc_dota_neutral_centaur_outrunner"] = 9,

	["npc_dota_neutral_alpha_wolf"] = 8,
	["npc_dota_neutral_giant_wolf"] = 5,

	["npc_dota_neutral_satyr_soulstealer"] = 5,
	["npc_dota_neutral_satyr_trickster"] = 4,

	["npc_dota_neutral_mud_golem"] = 5,
	["npc_dota_neutral_mud_golem_split"] = 2,

	["npc_dota_neutral_ogre_magi"] = 6,
	["npc_dota_neutral_ogre_mauler"] = 6, 





	["npc_dota_neutral_polar_furbolg_ursa_warrior"] = 15,
	["npc_dota_neutral_polar_furbolg_champion"] = 10,

	["npc_dota_neutral_satyr_hellcaller"] = 16,

	["npc_dota_neutral_centaur_khan"] = 9,

	["npc_dota_neutral_wildkin"] = 5, 
	["npc_dota_neutral_enraged_wildkin"] = 16,

	["npc_dota_neutral_dark_troll"] = 5,
	["npc_dota_neutral_dark_troll_warlord"] = 16, 

	["npc_dota_neutral_warpine_raider"] = 13,



	["npc_dota_neutral_black_dragon"] = 20,
	["npc_dota_neutral_black_drake"] = 13,

	["npc_dota_neutral_granite_golem"] = 20,
	["npc_dota_neutral_rock_golem"] = 13,

	["npc_dota_neutral_big_thunder_lizard"] = 20,
	["npc_dota_neutral_small_thunder_lizard" ] = 13,  

	["npc_dota_neutral_ice_shaman" ] = 20,  
	["npc_dota_neutral_frostbitten_golem"] = 13,


	["npc_filler_dire_stun"] = 40,
	["npc_filler_dire_plasma"] = 40,
	["npc_filler_dire_resist"] = 40,
	["npc_filler_radiant_stun"] = 40,
	["npc_filler_radiant_plasma"] = 40,
	["npc_filler_radiant_resist"] = 40,

	["patrol_melee_good"] = 5,
	["patrol_range_good"] = 5,
	["patrol_melee_bad"] = 5,
	["patrol_range_bad"] = 5,

	["npc_muerta_ursa"] = 50,
	["npc_muerta_satyr"] = 50,
	["npc_muerta_centaur"] = 50,
	["npc_muerta_ogre"] = 50,

} 



function my_game:IsAncientCreep( unit )
if not IsServer() then return end
name = unit:GetUnitName()
if name == "npc_dota_neutral_black_dragon" 
or	name == "npc_dota_neutral_black_drake" 
or	name == "npc_dota_neutral_granite_golem"
or	name == "npc_dota_neutral_rock_golem" 
or	name == "npc_dota_neutral_big_thunder_lizard" 
or	name == "npc_dota_neutral_small_thunder_lizard"  then return true end  

return false 
end



function my_game:FillQuests(hero_name)

local new_quests = {}
local normal_quests = {}
local legendary_quests = {}
local general_quests = {}

for number,shop_hero_quest in pairs(All_Quests.hero_quests[hero_name]) do 
	if shop_hero_quest.legendary and shop_hero_quest.legendary ~= nil then 
		legendary_quests[#legendary_quests + 1] = number
	else 
		normal_quests[#normal_quests + 1] = number
	end
end

for number,shop_hero_quest in pairs(All_Quests.general_quests) do 

	if (shop_hero_quest.not_for == nil or shop_hero_quest.not_for[hero_name] == nil) and 
	(shop_hero_quest.only_for == nil or shop_hero_quest.only_for[hero_name] ~= nil) then 
		general_quests[#general_quests + 1] = number
	end
end


if #normal_quests > 0 then 
	new_quests[#new_quests + 1] = All_Quests.hero_quests[hero_name][normal_quests[RandomInt(1, #normal_quests)]].name
end

if #legendary_quests > 0 then 
	new_quests[#new_quests + 1] = All_Quests.hero_quests[hero_name][legendary_quests[RandomInt(1, #legendary_quests)]].name
end


if #general_quests > 0 then 

	local name = All_Quests.general_quests[general_quests[RandomInt(1, #general_quests)]].name
	new_quests[#new_quests + 1] = name

end

return new_quests
end





_G.GAME_STARTED = false


function my_game:OnGameRulesStateChange()
	--my_game:UpdateMatch(true)


	local nNewState = GameRules:State_Get()

	if nNewState == DOTA_GAMERULES_STATE_CUSTOM_GAME_SETUP then
		HTTP.FillOfflineServerData()
		_G.GAME_STARTED = true

		HTTP.MatchStart()

		for id = 0, 24 do
			if PlayerResource:IsValidPlayerID(id) and PlayerResource:GetSteamAccountID(id) ~= 0 then
				_G.PlayerCount = _G.PlayerCount + 1



				PartyTable[id] = tostring(PlayerResource:GetPartyID(id))

				CustomNetTables:SetTableValue(
					"reports",
					tostring(id),
					{
						report = 1
					}
				)
			end
		end

		if PlayerCount <= TestMode_players then 
			_G.TestMode = true
		end
	end


	if nNewState == DOTA_GAMERULES_STATE_HERO_SELECTION then


		CustomNetTables:SetTableValue(
			"custom_pick",
			"pick_state",
			{
				in_progress = true,
			}
		)

		CustomNetTables:SetTableValue(
			"custom_pick",
			"avg_rating",
			{
				avg_rating = avg_rating
			}
		)

	
		Timers:CreateTimer(
			"",
			{
				useGameTime = false,
				endTime = 1,
				callback = function()

					GameRules:GetGameModeEntity():SetThink( check_connect, "check_connect_timer", 0.5 )
					hero_select:init()
			end})

	end	


	if nNewState == DOTA_GAMERULES_STATE_PRE_GAME then
		my_game:PreGame()
	end



	if nNewState == DOTA_GAMERULES_STATE_GAME_IN_PROGRESS then 
		my_game:start_game()
	end

end




function my_game:CreateUpgradeOrb(hero, rarity)
if not IsServer() then return end

local name = {"item_gray_upgrade","item_blue_upgrade","item_purple_upgrade","item_legendary_upgrade"}
local sound = {"powerup_04","powerup_03","powerup_05","powerup_02"}
local effect = {"particles/gray_drop.vpcf","particles/blue_drop.vpcf","particles/purple_drop.vpcf", "particles/orange_drop.vpcf"}

if rarity == 3 then
	players[hero:GetTeamNumber()].purple = players[hero:GetTeamNumber()].purple + 1
end

if hero.owner then
	hero = hero.owner
end

local point = Vector(0, 0, 0)

if hero:IsAlive() and not hero:HasModifier("modifier_duel_hero_end") and not hero:HasModifier("modifier_duel_hero_thinker") then
	point = hero:GetAbsOrigin() + RandomVector(150)
else
	if towers[hero:GetTeamNumber()] ~= nil then
		point = towers[hero:GetTeamNumber()]:GetAbsOrigin() + towers[hero:GetTeamNumber()]:GetForwardVector() * 300
	end
end

local item = CreateItem(name[rarity], hero, hero)

item_effect = ParticleManager:CreateParticle(effect[rarity], PATTACH_WORLDORIGIN, nil)
ParticleManager:SetParticleControl(item_effect, 0, point)

EmitSoundOnEntityForPlayer(sound[rarity], hero, hero:GetPlayerOwnerID())

item.after_legen = After_Lich

Timers:CreateTimer(0.8,function() CreateItemOnPositionSync(GetGroundPosition(point, unit), item) end)
	

end




function my_game:AddPurplePoints(hero, points)
if not IsServer() then return end
if not players[hero:GetTeamNumber()] then return end

players[hero:GetTeamNumber()].purplepoints = players[hero:GetTeamNumber()].purplepoints + points


if players[hero:GetTeamNumber()].purplepoints >= math.floor(players[hero:GetTeamNumber()].purplemax) then

	CustomGameEventManager:Send_ServerToPlayer(
		PlayerResource:GetPlayer(hero:GetPlayerOwnerID()),
		"kill_progress",
		{
			blue = math.floor(players[hero:GetTeamNumber()].bluepoints),
			purple = math.floor(players[hero:GetTeamNumber()].purplemax),
			max = players[hero:GetTeamNumber()].bluemax,
			max_p = math.floor(players[hero:GetTeamNumber()].purplemax)
		}
	)

	Timers:CreateTimer(
		0.5,
		function()
			CustomGameEventManager:Send_ServerToPlayer(
				PlayerResource:GetPlayer(hero:GetPlayerOwnerID()),
				"kill_progress",
				{
					blue = math.floor(players[hero:GetTeamNumber()].bluepoints),
					purple = players[hero:GetTeamNumber()].purplepoints,
					max = players[hero:GetTeamNumber()].bluemax,
					max_p = math.floor(players[hero:GetTeamNumber()].purplemax)
				}
			)
		end)

	players[hero:GetTeamNumber()].purplepoints = players[hero:GetTeamNumber()].purplepoints - math.floor(players[hero:GetTeamNumber()].purplemax)
	players[hero:GetTeamNumber()].purplemax = players[hero:GetTeamNumber()].purplemax + PlusPurple

	my_game:CreateUpgradeOrb(hero, 3)

	else
		CustomGameEventManager:Send_ServerToPlayer(
		PlayerResource:GetPlayer(hero:GetPlayerOwnerID()),
			"kill_progress",
			{
				blue = math.floor(players[hero:GetTeamNumber()].bluepoints),
				purple = players[hero:GetTeamNumber()].purplepoints,
				max = players[hero:GetTeamNumber()].bluemax,
				max_p = math.floor(players[hero:GetTeamNumber()].purplemax)
			}
		)
	end
end





function my_game:AddBluePoints(hero, points)
if not IsServer() then return end

local k = 1

if players[hero:GetTeamNumber()]:HasModifier("modifier_up_bluepoints") then
	--k = k + BlueMorePoints
end


players[hero:GetTeamNumber()].bluepoints = players[hero:GetTeamNumber()].bluepoints + points * k

if players[hero:GetTeamNumber()].bluepoints >= players[hero:GetTeamNumber()].bluemax then

	CustomGameEventManager:Send_ServerToPlayer(PlayerResource:GetPlayer(hero:GetPlayerOwnerID()),
				"kill_progress",
				{
					blue = players[hero:GetTeamNumber()].bluemax,
					purple = players[hero:GetTeamNumber()].purplepoints,
					max = players[hero:GetTeamNumber()].bluemax,
					max_p = math.floor(players[hero:GetTeamNumber()].purplemax)
				}
			)

	Timers:CreateTimer(0.5,function()
		CustomGameEventManager:Send_ServerToPlayer(PlayerResource:GetPlayer(hero:GetPlayerOwnerID()),
				"kill_progress",
				{
					blue = math.floor(players[hero:GetTeamNumber()].bluepoints),
					purple = players[hero:GetTeamNumber()].purplepoints,
					max = players[hero:GetTeamNumber()].bluemax,
					max_p = math.floor(players[hero:GetTeamNumber()].purplemax)
				}
			)
	end)

	players[hero:GetTeamNumber()].bluepoints = players[hero:GetTeamNumber()].bluepoints - players[hero:GetTeamNumber()].bluemax
	players[hero:GetTeamNumber()].bluemax = players[hero:GetTeamNumber()].bluemax + PlusBlue

	my_game:CreateUpgradeOrb(hero, 2)
else
	CustomGameEventManager:Send_ServerToPlayer(PlayerResource:GetPlayer(hero:GetPlayerOwnerID()),
			"kill_progress",
			{
				blue = math.floor(players[hero:GetTeamNumber()].bluepoints),
				purple = players[hero:GetTeamNumber()].purplepoints,
				max = players[hero:GetTeamNumber()].bluemax,
				max_p = math.floor(players[hero:GetTeamNumber()].purplemax)
			}
		)
end


end












function check_reports()

for _,server_player in pairs(HTTP.serverData.players) do

	local pid = HTTP.GetPlayerBySteamID( server_player.steamID )

	local player = nil

	if pid then 
		player = players[PlayerResource:GetTeam(pid)]
	end

	if player ~= nil and server_player.reports then

		if player.banned ~= true then
			player.banned = server_player.isBanned
		end

		for other_player, report_count in pairs(server_player.reports) do

			local other_pid = HTTP.GetPlayerBySteamID( other_player )

			if report_count > 0 then 
				CustomGameEventManager:Send_ServerToPlayer(PlayerResource:GetPlayer(pid), 'report_alert',  {
			   	 id = other_pid,
			   	 number = report_count,
			   	 max = 6
				})
			end

			if report_count > player.reports then
				player.reports = report_count
				player.teammate = other_pid
			end
		end
	end
end


end



function my_game:DestroyRoshan()

CustomGameEventManager:Send_ServerToAllClients( 'roshan_hide', {} )
Active_Roshan = false	
end


function my_game:OnItemPickUp( event )
local item = EntIndexToHScript( event.ItemEntityIndex )

local owner
if event.HeroEntityIndex then
	owner = EntIndexToHScript(event.HeroEntityIndex)
elseif event.UnitEntityIndex then
	owner = EntIndexToHScript(event.UnitEntityIndex)
end

if not owner:IsRealHero() then return end

if event.itemname == "item_aegis" then
    UTIL_Remove( item )
    owner:AddNewModifier(owner, nil, "modifier_aegis_custom", {duration = 300})
end


local hero = players[owner:GetTeamNumber()]

if not hero:HasModifier("modifier_end_choise") and players[owner:GetTeamNumber()].PickOrbs == 0 then 
   
	local after_legen = false
	if item.after_legen == true then 
		after_legen = true
	end


    if event.itemname == "item_gray_upgrade" then
   	 		upgrade:init_upgrade(owner,1,nil,after_legen)
        	UTIL_Remove( item )
    end

    if event.itemname == "item_blue_upgrade" then
   	 		upgrade:init_upgrade(owner,2,nil,after_legen)
       		 UTIL_Remove( item )
    end
    if event.itemname == "item_purple_upgrade" then
   	 		upgrade:init_upgrade(owner,3,nil,after_legen)
       		 UTIL_Remove( item )

    end
    if event.itemname == "item_purple_upgrade_shop" then
   	 		upgrade:init_upgrade(owner,3,nil,true)
       		 UTIL_Remove( item )

    end
    if event.itemname == "item_legendary_upgrade" then
   	 		upgrade:init_upgrade(owner,4,nil,after_legen)		
        	UTIL_Remove( item )	
    end
        
    if event.itemname == "item_alchemist_recipe" then
   	 		upgrade:init_upgrade(owner,13,nil,nil)		
        	UTIL_Remove( item )	
    end
end	



end









function _G.Check_position(i)


local point = i:GetAbsOrigin()
local change = false  



if i:GetAbsOrigin().z < -1000 then 
	point.z = i.z
	change = true
end 

if i:GetAbsOrigin().x > i.x_max then 
	point.x = i.x_max - 200
	change = true
end

if i:GetAbsOrigin().x < i.x_min then 
	point.x = i.x_min + 200
	change = true
end

if i:GetAbsOrigin().y > i.y_max then 
	point.y = i.y_max - 200
	change = true
end

if i:GetAbsOrigin().y < i.y_min then 
	point.y = i.y_min + 200 
	change = true	
end   

if change == true then 
	i:SetAbsOrigin(point)
	FindClearSpaceForUnit(i, point, true)
end




end


function my_game:StartTargetCooldown()

Target_current_cooldown = Target_cooldown
Target_current_active = false

end



_G.RemoveForDuel =
{
	["modifier_smoke_of_deceit"] = true,
	["modifier_item_revenants_brooch_counter"] = true,
	["modifier_item_hurricane_pike_range"] = true,
	["modifier_sven_gods_strength"] = true,
}


function my_game:EndAllCooldowns(caster)


local allunits = FindUnitsInRadius( caster:GetTeamNumber(), Vector(0, 0, 0), nil, FIND_UNITS_EVERYWHERE, DOTA_UNIT_TARGET_TEAM_FRIENDLY, DOTA_UNIT_TARGET_ALL, DOTA_UNIT_TARGET_FLAG_MAGIC_IMMUNE_ENEMIES + DOTA_UNIT_TARGET_FLAG_INVULNERABLE + DOTA_UNIT_TARGET_FLAG_OUT_OF_WORLD, 0, false )

for _,unit in ipairs(allunits) do

	if unit and not unit:IsNull() then 

		for __,mod in pairs(unit:FindAllModifiers()) do
			if mod:GetName() == "modifier_monkey_king_wukongs_command_custom_soldier_active" then 
				unit:RemoveModifierByName("modifier_monkey_king_wukongs_command_custom_soldier_active")
				break
			end
		end

		if unit.owner and unit.owner == caster and (unit:IsIllusion() or unit:IsTempestDouble() or unit:HasModifier("modifier_custom_juggernaut_healing_ward"))
			and not unit:HasModifier("modifier_monkey_king_wukongs_command_custom_soldier") then 

			if unit:IsTempestDouble() then 
				my_game:RefreshCooldowns(unit)
			end 

	 		unit:Kill(nil, unit)
		end
	end

end


for _,mod in pairs(caster:FindAllModifiers()) do

	if (mod.RemoveForDuel and mod.RemoveForDuel == true) or RemoveForDuel[mod:GetName()] then
		mod:Destroy()
	end

end


local thinkers = Entities:FindAllByClassname("npc_dota_thinker")

for _,thinker in pairs(thinkers) do 
	if thinker:GetTeamNumber() == caster:GetTeamNumber() then 
	--	UTIL_Remove(thinker)
	end 
end


local all_units = FindUnitsInRadius(caster:GetTeamNumber(), Vector(0,0,0), nil, FIND_UNITS_EVERYWHERE, DOTA_UNIT_TARGET_TEAM_FRIENDLY, DOTA_UNIT_TARGET_BASIC, DOTA_UNIT_TARGET_FLAG_OUT_OF_WORLD + DOTA_UNIT_TARGET_FLAG_INVULNERABLE + DOTA_UNIT_TARGET_FLAG_MAGIC_IMMUNE_ENEMIES, 0, false)

for _,unit in pairs(all_units) do 
  if unit:GetUnitName() == "npc_dota_wraith_king_skeleton_warrior_custom" or
  	unit:GetUnitName() == "npc_dota_wraith_king_skeleton_ghost_custom" then 
  		unit:RemoveModifierByName("modifier_skelet_reincarnation")
  		unit:Kill(nil, nil)
  	end
end

for i = 0,caster:GetAbilityCount()-1 do
	local a = caster:GetAbilityByIndex(i)

	if not a or a:GetName() == "ability_capture" then break end

	if a:GetName() == "skeleton_king_vampiric_aura_custom" then 
		local mod = caster:FindModifierByName("modifier_skeleton_king_vampiric_aura_custom") 
		if mod then 
			mod:SetStackCount(a:GetSpecialValueFor("max_skeleton_charges"))
		end
	end 

	if a:GetToggleState() then 
		a:ToggleAbility()
	end 
  
	
end

my_game:RefreshCooldowns(caster)
end







function my_game:RefreshCooldowns(caster, effect)



if effect then 

	if caster:IsAlive() then 
		caster:SetHealth(caster:GetMaxHealth())
		caster:SetMana(caster:GetMaxMana())
	end 

	local particle = ParticleManager:CreateParticle("particles/items2_fx/refresher.vpcf", PATTACH_CUSTOMORIGIN, caster)
	ParticleManager:SetParticleControlEnt( particle, 0, caster, PATTACH_POINT_FOLLOW, "attach_hitloc", caster:GetOrigin(), true )
	ParticleManager:ReleaseParticleIndex(particle)

	caster:EmitSound("DOTA_Item.Refresher.Activate")	

end 

for i = 0, 20 do
	local current_ability = caster:GetAbilityByIndex(i)

	if current_ability then
		current_ability:EndCooldown()
		current_ability:RefreshCharges()
	end
end



for i = 0, 8 do
	local current_item = caster:GetItemInSlot(i)
	

	if current_item then	
		if current_item:GetName() ~= "item_refresher_custom" then 
			current_item:EndCooldown()		
		end
		if current_item:GetName() == "item_aegis" then 
			--current_item:Destroy()
		end
	end
end


local neutral = caster:GetItemInSlot(16) 
if neutral then
	neutral:EndCooldown()
end

end 






function _G.Destroy_Wave_Creeps()

local wave_creeps = FindUnitsInRadius(DOTA_TEAM_NOTEAM, Vector(0,0,0), nil, FIND_UNITS_EVERYWHERE, DOTA_UNIT_TARGET_TEAM_BOTH, DOTA_UNIT_TARGET_ALL, DOTA_UNIT_TARGET_FLAG_MAGIC_IMMUNE_ENEMIES, 0, false)
for _,wave_creep in ipairs(wave_creeps) do
	if not wave_creep:IsNull() and wave_creep:GetTeamNumber() == DOTA_TEAM_CUSTOM_5 and wave_creep:IsAlive() and not wave_creep.player_unit then 

		wave_creep:ForceKill(false)
	end
end

end


function my_game:Destroy_All_Units(caster)

local thirst = caster:FindAbilityByName("bloodseeker_thirst_custom")

if thirst and caster:HasModifier("modifier_bloodseeker_thirst_7") then 
	local mod = caster:FindModifierByName("modifier_bloodseeker_thirst_custom_legendary")

	if mod then 
		caster:RemoveModifierByName("modifier_bloodseeker_thirst_custom_vision")

		mod:SetStackCount(mod.perma_stack + caster:GetTalentValue("modifier_bloodseeker_thirst_7", "max"))
	end 

end 


local all_units = FindUnitsInRadius(caster:GetTeamNumber(), Vector(0,0,0), nil, FIND_UNITS_EVERYWHERE, DOTA_UNIT_TARGET_TEAM_FRIENDLY, DOTA_UNIT_TARGET_ALL, DOTA_UNIT_TARGET_FLAG_MAGIC_IMMUNE_ENEMIES + DOTA_UNIT_TARGET_FLAG_INVULNERABLE + DOTA_UNIT_TARGET_FLAG_PLAYER_CONTROLLED, 0, false)
for _,unit in ipairs(all_units) do
	if not unit:IsNull() and unit:IsAlive() and not unit:IsRealHero() and not unit:IsCourier()
	and not unit:HasModifier("modifier_monkey_king_wukongs_command_custom_soldier") then 
		unit:ForceKill(false)
	end
end

end




function my_game:DestroyPatrol()
if not IsServer() then return end

local patrols = FindUnitsInRadius(1, Vector(0,0,0), nil, FIND_UNITS_EVERYWHERE, DOTA_UNIT_TARGET_TEAM_BOTH, DOTA_UNIT_TARGET_BASIC, DOTA_UNIT_TARGET_FLAG_INVULNERABLE + DOTA_UNIT_TARGET_FLAG_OUT_OF_WORLD + DOTA_UNIT_TARGET_FLAG_MAGIC_IMMUNE_ENEMIES, FIND_CLOSEST, false)

for _,patrol in pairs(patrols) do
	if patrol:GetUnitName() == "patrol_melee_good" or
		 patrol:GetUnitName() == "patrol_melee_bad" or
		  patrol:GetUnitName() == "patrol_range_good" or
		   patrol:GetUnitName() == "patrol_range_bad" then 

		patrol:AddNewModifier(patrol, nil, "modifier_death", {})

		patrol:ForceKill(false)
	end
end


end


function MaxTime(n)
local t = 70
if n == 1 then t = 20 end 
if n >= 6 then t = 120 end
if n >= 14 then t = 180 end
if n >= 21 then t = 180 end
return t
end



my_game.patrol_drop_first = 
{
	"item_ward_observer",
	--"item_repair_patrol",
	"item_patrol_warp_amulet",
	"item_contract",
	"item_patrol_restrained_orb",
	--"item_smoke_of_deceit",
	"item_patrol_midas",
}


my_game.patrol_drop_second = 
{
	--"item_patrol_upgrade",
	"item_patrol_vision",
	"item_roshan_necro",
	--"item_patrol_grenade",
	"item_patrol_fortifier",
	--"item_trap_custom",
	"item_patrol_respawn",
	"item_patrol_razor",
	"item_patrol_refresh",
}



function my_game:TimerAlerts()


if GameRules:GetDOTATime(false, false) >= DoubleRating_timer and DoubleRating_active == true then 
	DoubleRating_active = false
	CustomGameEventManager:Send_ServerToAllClients( 'hide_double_rating', {} ) 
end

if GameRules:GetDOTATime(false, false) >= push_timer and push_alert == false then 
	push_alert = true
	CustomGameEventManager:Send_ServerToAllClients( 'grenade_alert', {} ) 
end

if GameRules:GetDOTATime(false, false) >= patrol_first_tier and  patrol_first_init == false then 
	patrol_first_init = true 
	CustomGameEventManager:Send_ServerToAllClients( 'PatrolAlert', {number = 1, items = my_game.patrol_drop_first} )
end  

if GameRules:GetDOTATime(false, false) >= patrol_second_tier and  patrol_second_init == false then 
	patrol_second_init = true 
	CustomGameEventManager:Send_ServerToAllClients( 'PatrolAlert', {number = 2, items = my_game.patrol_drop_second} )
end  

if (MaxTimer - timer) <= duel_alert_timer and duel_alert_init == false and my_game:FinalDuel() == false then 

	local array = {}

	for _,data in pairs(duel_data) do 
		if data.stage == 1 and data.finished == 0 and data.final_duel == 0
			and players[data.hero1:GetTeamNumber()] and players[data.hero2:GetTeamNumber()] then 
			local names = {}
			table.insert(names, data.hero1:GetUnitName())
			table.insert(names, data.hero2:GetUnitName())

			table.insert(array, names)
		end 
	end 

	if #array > 0 then 
		duel_alert_init = true
		CustomGameEventManager:Send_ServerToAllClients( "DuelAlert", {array = array} )
	end
end

end 


function my_game:FinalDuel()
if duel_data[#duel_data] and duel_data[#duel_data].finished == 0 and duel_data[#duel_data].final_duel == 1 then 
	return true
else 
	return false
end 

end




function spawn_timer()

if ReadyPlayers == 0 then  return 1 end
if GameRules:IsGamePaused() == true then return 1 end
if Game_end == true then return -1 end


my_game:TimerAlerts()

my_game:MuertaQuestTimer()




if my_game:FinalDuel() == true then 

else 
	MaxTimer = MaxTime(my_game.current_wave + 1)
	
	if test then
		if my_game.current_wave + 1 == start_wave + 1 then 
			MaxTimer = timer_test_start
		else  
			MaxTimer = timer_test
		end
	end 
end 




if game_start == true then 

	if TimerStop == false then 
		timer = timer + 1
	end

	bounty_timer = bounty_timer + 1 

	for _,data in pairs(duel_data) do 
		if data and data.finished and data.finished == 0 and data.thinker and not data.thinker:IsNull() then 
			data.timer = data.timer + 1 

			if data.timer >= data.max_timer and data.thinker and not data.thinker:IsNull() then 
				data.thinker:RemoveModifierByName("modifier_duel_field_thinker")
			end 

		end 
	end 
end


if my_game:FinalDuel() == true and duel_data[#duel_data].new_round == true then 
	duel_data[#duel_data].new_round = false

	MaxTimer = round_timer
	timer = 0
end








local net = {}
local max_net = 0
local max_team = 0	

for team,player in pairs(players) do 

	if player.left_game == true then 
		player.left_game_timer = player.left_game_timer - 1
	end

    player.on_streak = false 


   	local i = #net + 1

   	net[i] = {}

	net[i].gold = PlayerResource:GetNetWorth(player:GetPlayerOwnerID())
	net[i].team = team

	if max_net < net[i].gold and max_team ~= team then 
		max_net = net[i].gold
		max_team = team
	end

end

if players[max_team] then 
	players[max_team].on_streak = true
	
end 


if test and net[2] == nil then
	net[2] = {}

	net[2].gold = 5000
	net[2].team = 3
end


local low_net = 0
local low_net_2 = 0

if #net > 3 or (test and #net > 1) then 

    table.sort( net, function(x,y) return y.gold > x.gold end )

	if (net[2].gold - net[1].gold)/net[1].gold > low_net_diff then 
		low_net = net[1].team
		low_net_2 = net[2].team
	end


	if (my_game.current_wave + 1) > 6 or test then 

		for _,player in pairs(players) do
			player.givegold = false
		end

		for i = 1, math.floor(#net/2) do
			if players[net[i].team] ~= nil then 
				players[net[i].team].givegold = true
			end
		end 

	end

end 




local number_wave = 0
local go_boss = false


if timer >= MaxTimer then 

	if my_game:FinalDuel() == false then 

		if muerta_quest_phase ~= 0 and muerta_quest_hero ~= nil then 

			my_game:MuertaQuestClearArea()
			muerta_quest_timer = 0
			muerta_quest_active = true

		end

		my_game.current_wave = my_game.current_wave + 1


		for n = 1,#Wave_boss_number do 
			if my_game.current_wave == Wave_boss_number[n] then
				go_boss = true
				break
			end 
		end

		if go_boss then 
			my_game.go_boss_number = my_game.go_boss_number + 1
			number_wave = my_game.go_boss_number
		else 
			my_game.go_wave = my_game.go_wave + 1
			number_wave = my_game.go_wave
		end

		my_game:DestroyPatrol()

		if low_net_waves[my_game.current_wave] then 
			low_net_current = low_net_current + 1
		end

	end 
end 




for team,player in pairs(players) do
	

	local id = player:GetPlayerOwnerID()

	if GameRules:GetDOTATime(false, false) >= Player_damage_time and GameRules:GetDOTATime(false, false) < Player_damage_time + 3 then 

		player:RemoveModifierByName("modifier_player_damage")

		player.damage_bonus = 0
	end


	for timing,state in pairs(player.ItemsTiming) do 

		if state == false and GameRules:GetDOTATime(false, false) >= timing then 
			HTTP.FillItemsData(id, -1)

			player.ItemsTiming[timing] = true
			break
		end 	
	end 	

	if player.necro_cd > 0 then 
		player.necro_cd = player.necro_cd - 1
	end 

	
	player.active_necro = (MaxTimer - timer) > Necro_Timer

	if duel_data[player.duel_data] and duel_data[player.duel_data].finished == 0 and duel_data[player.duel_data].stage == 1
	and (MaxTimer - timer) <= duel_necro_time and towers[player:GetTeamNumber()] and not towers[player:GetTeamNumber()]:HasModifier("modifier_tower_incoming_duel_soon") then 

		towers[player:GetTeamNumber()]:AddNewModifier(towers[player:GetTeamNumber()], nil, "modifier_tower_incoming_duel_soon", {duration = (MaxTimer - timer) + 1})
	end 


	if duel_data[player.duel_data] and duel_data[player.duel_data].finished == 0 and duel_data[player.duel_data].stage == 1
		and (MaxTimer - timer) <= duel_push_teleport and not player:HasModifier("modifier_duel_hero_teleport") then 

		player:AddNewModifier(player, nil, "modifier_duel_hero_teleport", {duration = duel_push_teleport})
	end 


	local hero_has_aegis = false
	player.no_purple = false
	player.lowest_net = 0

	local no_purple = 0

	if team == low_net or team == low_net_2 then 
		player.lowest_net = 1
	end

	local hero_name = ""

	hero_name = player:GetUnitName()
	hero_has_aegis = player:HasModifier("modifier_aegis_custom")


	no_buyback = player.no_buyback


	local hero_kills_table = nil
	if GameRules:GetDOTATime(false, false) < Player_damage_time then 
		hero_kills_table = player.hero_kills
	end

	if towers[player:GetTeamNumber()] and not duel_data[player.duel_data]
		and timer + PortalDelay == MaxTimer and my_game:FinalDuel() == false then 

		my_game:spawn_portal(player:GetTeamNumber())
	end 


	if timer + 10 == MaxTimer and game_start == true and my_game:FinalDuel() == false and 
		teleports[player:GetTeamNumber()] and not duel_data[player.duel_data] then 

		local table_tips = CustomNetTables:GetTableValue("TipsType", tostring(player:GetPlayerOwnerID()))
		local count = 0
		local teleport = teleports[player:GetTeamNumber()]:GetName()
		teleport = tonumber(teleport)

		if table_tips.type == 2 or table_tips.type == 3 then
			Timers:CreateTimer(0, function()
				GameRules:ExecuteTeamPing( player:GetTeamNumber(), vision_abs[teleport][1], vision_abs[teleport][2], player, 0 )
				count = count + 1
				if count <= 2 then
					return 1.5
				end
			end)
		end

		if table_tips.type == 3 then
			CustomGameEventManager:Send_ServerToPlayer(PlayerResource:GetPlayer(id), "TipForPlayer", {duration = 10, text = "#Tip_WaveStart"})
		end

	end 


	if timer >= MaxTimer then 

		player.used_necro = false

		if duel_data[player.duel_data] and duel_data[player.duel_data].finished == 0 then 

			if duel_data[player.duel_data].final_duel == 1 then 
				Destroy_Wave_Creeps()	
			end 

			my_game:CreateDuelField(player.duel_data)

		else 

			local necro = false 
			local trap = false

			if player.trap_wave == true then 
				trap = true 
				player.trap_wave = false
			end

			if player.necro_wave == true then 
				necro = true 
				player.necro_wave = false
			end

			local give_lownet = 0
			if player.lowest_net == 1 and low_net_waves[my_game.current_wave] then 
				give_lownet = 1
			end

			my_game:spawn_wave(team, number_wave, go_boss, necro, give_lownet, trap)

		end 

		if towers[team] ~= nil and my_game.current_wave < 25 and my_game.current_wave > 1 then 
			towers[team]:AddNewModifier(player, nil, "modifier_tower_level", {})
		end

	end


	Check_position(player)


	CustomNetTables:SetTableValue("networth_players", tostring(id), {
	    place = -1,
	    team = team,
	    no_buyback = no_buyback,
	    net = PlayerResource:GetNetWorth(id),
	    damage_bonus = player.damage_bonus,
	    hero_kills = hero_kills_table,
	    streak = player.on_streak,
	    hero_has_aegis = hero_has_aegis,
	    hero_tier = player.hero_tier,
	    hero_name = hero_name,
	    validGame = HTTP.IsValidGame(PlayerCount),
	})

end




if timer >= MaxTimer then 

	duel_alert_init = false

	if my_game:FinalDuel() == false and my_game:IsDuelWave() then 
		my_game:FindDuelPairs()
	end 

	if my_game.go_wave == #waves then 
		my_game.go_wave = 0
	end 


	if #net > 3 and (my_game.current_wave >= Target_start_wave and my_game.current_wave < Target_end_wave) then 


		local first_player = players[net[#net].team]
		local diff = net[#net].gold/net[#net-1].gold
		
		if first_player and diff >= Target_gold and (net[#net].gold - net[#net-1].gold >= Target_gold_min) and first_player:IsAlive() then

			first_player:AddNewModifier(first_player, nil, "modifier_target", {duration = MaxTime(my_game.current_wave + 1)})

			Target_start_wave = Target_start_wave + Target_cooldown
		end
	end


	timer = 0
end







if GameRules:GetDOTATime(false, false) >= bounty_start and bounty_init == false then 
	bounty_init = true 

	for i = 1,#bounty_abs do 
		local b_thinker = CreateUnitByName("npc_bounty_thinker", bounty_abs[i], false, nil, nil, DOTA_TEAM_NEUTRALS)
		b_thinker:AddNewModifier(b_thinker, nil, "modifier_bounty_map", {})

	end
end


if bounty_timer >= bounty_max_timer and GameRules:GetDOTATime(false, false) >= bounty_start then 
	bounty_timer = 0

	for i = 1,#bounty_abs do 

		local near_rune = Entities:FindByModelWithin(nil, "models/props_gameplay/rune_goldxp.vmdl", bounty_abs[i], 200)
		if not near_rune then
			CreateRune(bounty_abs[i], DOTA_RUNE_BOUNTY)  
		end

	end
end





local patrol_max = patrol_timer_max

if my_game.current_wave >= patrol_wave_2 then 
	patrol_max = patrol_timer_max_2
end 

if patrol_wave <= my_game.current_wave and timer + PortalDelay == patrol_max and my_game:FinalDuel() == false then 


	if my_game.patrol_dontgo_dire == true or my_game.patrol_dontgo_radiant == true then 
		if my_game.dire_patrol_alive == false then 
			my_game:patrol_portal(2) 
		end
	else 
	
		if my_game.radiant_patrol_alive == false and my_game.patrol_dontgo_radiant== false then 	
			my_game:patrol_portal(0)
		end
		if my_game.dire_patrol_alive == false and my_game.patrol_dontgo_dire == false then 
			my_game:patrol_portal(1)
		end

	end
end


if patrol_wave <= my_game.current_wave and timer == patrol_max and my_game:FinalDuel() == false then 

	local drop = my_game.patrol_drop_first

	local second_tier = false 
	local center_patrol = false
	my_game.ravager_max = 12

	if my_game.patrol_dontgo_dire == true or my_game.patrol_dontgo_radiant == true then
		center_patrol = true
		my_game.ravager_max = 6
	end 


	local patrol_item = "item_patrol_reward_1"

	if my_game.current_wave >= patrol_wave_2 then 

		drop = my_game.patrol_drop_second
		second_tier = true
		patrol_item  = "item_patrol_reward_2"

		if my_game.current_wave == patrol_wave_2 then 
			patrol_item  = "item_patrol_reward_2_no_gadget"
		end 

	end



	if center_patrol then 
		if my_game.dire_patrol_alive == false then 
		
			my_game.dire_patrol_alive = true
			my_game:spawn_patrol(RandomInt(0,1), patrol_item, patrol_item, second_tier, true)
		end
	else 
		item_2 = ""

		if my_game.radiant_patrol_alive == false and my_game.patrol_dontgo_radiant == false then 
			my_game.radiant_patrol_alive = true
			my_game:spawn_patrol(0, patrol_item, nil ,second_tier, false)
		end
   	
		if my_game.dire_patrol_alive == false and my_game.patrol_dontgo_dire == false then 
			my_game.dire_patrol_alive = true
			my_game:spawn_patrol(1, patrol_item, nil,second_tier, false)
		end
	end 

	my_game.current_patrol = my_game.current_patrol + 1 
	if my_game.current_patrol == 4 then 
		my_game.current_patrol = 1
	end
end



local next_boss = false
local next_wave_number = 0

for n = 1,#Wave_boss_number do 

	if my_game.current_wave + 1 == Wave_boss_number[n] then
		next_boss = true
		break

	end 
end


if next_boss then 
	next_wave_number = my_game.go_boss_number + 1
else 
	next_wave_number = my_game.go_wave + 1
end




local next_wave = my_game:GetWave(next_wave_number, next_boss)
local skills = my_game:GetSkills(next_wave_number, next_boss)
local mkb = my_game:GetMkb(next_wave_number, next_boss)
	



for id = 0,24 do 
	if PlayerResource:IsValidPlayerID(id) and PlayerResource:GetSteamAccountID(id) ~= 0  then  

		local can_display = false 
		local givegold = false
		local reward = 0
		local necro = 0
		local upgrade = 0

		local team = 0
		local player = nil


		if GlobalHeroes[id] ~= nil then 

			team = GlobalHeroes[id]:GetTeamNumber()
			player = players[team]

			if player ~= nil then 

				player.reward  = 1

				if (my_game.current_wave + 1) == Purple_Wave[1] or (my_game.current_wave + 1) == Purple_Wave[2] then 
					player.reward = 3  
				end

				local second_orange = 0

				if player.orange_count < 2 then 

					second_orange =  Wave_boss_number[2]
					if player:HasModifier("modifier_up_orangepoints") and my_game.current_wave < Wave_boss_number[2] then 
					
						if my_game.current_wave + 1 < upgrade_orange then 
							second_orange = upgrade_orange
						else 
							second_orange = my_game.current_wave + 1
						end
					end
				end

				if (my_game.current_wave + 1) == Wave_boss_number[1] or (my_game.current_wave + 1) == second_orange then 
					player.reward = 4 
				end


				reward = player.reward
				givegold = player.givegold
				can_display = player.ActiveWave == nil
				necro = player.necro_wave
				upgrade = player.creeps_upgrade
			else 
				can_display = true
			end

		else 
			can_display = true
		end

		local duel_timer = false

		local duel = nil 

		if (player and duel_data[player.duel_data] and duel_data[player.duel_data].finished == 0) or my_game:FinalDuel() == true then 
			


			if player and duel_data[player.duel_data] and duel_data[player.duel_data].finished == 0 then 
				duel = duel_data[player.duel_data]
			else 
				duel = duel_data[#duel_data]
			end 	
			duel_timer = true

		end 

		if can_display == true or my_game:FinalDuel() == true then 

			if duel_timer then 

				local time = timer
				local max_timer = MaxTimer

				if duel.stage == 2 then 
					time = duel.timer
					max_timer = duel.max_timer
				end 


				CustomGameEventManager:Send_ServerToPlayer(PlayerResource:GetPlayer(id) , 'duel_timer_progress',  
				{
					time = time, 
					max = max_timer, 
					stage = duel.stage, 
					final = duel.final_duel, 
					round = duel.rounds, 
					hero1 = duel.hero1:GetUnitName(), 
					wins1 = duel.wins1, 
					hero2 = duel.hero2:GetUnitName(),
					wins2 = duel.wins2,
					id1 = duel.hero1:GetPlayerOwnerID(),
					id2 = duel.hero2:GetPlayerOwnerID(),
				})


			else 

				CustomGameEventManager:Send_ServerToPlayer(PlayerResource:GetPlayer(id) , 'timer_progress',  
				{
					upgrade = upgrade,
					necro = necro,
					units = -1, 
					units_max = -1,  	
					time = timer, 
					max = MaxTimer, 
					name = next_wave, 
					skills = skills, 
					mkb = mkb, 
					reward = reward, 
					gold = givegold, 
					number = my_game.current_wave + 1, 
					game_start = game_start
				})
			end
		end

	end 
end

return 1
end


function my_game:IsDuelWave()
return my_game.current_wave >= duel_start_wave and my_game.current_wave % 2 == 0
end


function my_game:FindDuelPairs()


local net = {}

for team,player in pairs(players) do 

   	local i = #net + 1

   	net[i] = {}

	net[i].gold = PlayerResource:GetNetWorth(player:GetPlayerOwnerID())
	net[i].team = team

end


if #net > 1 then 
    table.sort( net, function(x,y) return y.gold > x.gold end )
else 
	return
end 





if #net > 3 then 
	local duel_1_hero_1 = net[#net].team
	local duel_1_hero_2 = -1
	local duel_2_hero_1 = net[#net - 3].team 
	local duel_2_hero_2 = -1

	local duel_3_hero_1 = -1
	local duel_3_hero_2 = -1 

	local duel_3_only_mid = false

	if #net == 6 then 

		duel_3_hero_1 = net[1].team
		duel_3_hero_2 = net[2].team

		if players[duel_3_hero_1] and players[duel_3_hero_2] then 

			if players[duel_3_hero_1]:IsMidPlayer() and players[duel_3_hero_2]:IsMidPlayer() then 
				duel_3_only_mid = true
			end 

			my_game:InitDuel(players[duel_3_hero_1],players[duel_3_hero_2], 0, not duel_3_only_mid)

		end 
	end 


	if not players[duel_1_hero_1] or not players[duel_2_hero_1] then 
		return
	end 

	if players[duel_1_hero_1].last_enemy ~= nil and players[duel_1_hero_1].last_enemy:GetTeamNumber() then 

		if players[duel_1_hero_1].last_enemy:GetTeamNumber() == net[#net - 1].team then 
			duel_1_hero_2 = net[#net - 2].team
			duel_2_hero_2 = net[#net - 1].team
		else 

			if players[duel_1_hero_1].last_enemy:GetTeamNumber() == net[#net - 2].team then 
				duel_1_hero_2 = net[#net - 1].team
				duel_2_hero_2 = net[#net - 2].team
			end 
		end 
	end 


	if duel_1_hero_2 == -1 then

		if players[duel_2_hero_1].last_enemy ~= nil and players[duel_2_hero_1].last_enemy:GetTeamNumber() then 

			if players[duel_2_hero_1].last_enemy:GetTeamNumber() == net[#net - 1].team then 
				duel_2_hero_2 = net[#net - 2].team
				duel_1_hero_2 = net[#net - 1].team
			else 

				if players[duel_2_hero_1].last_enemy:GetTeamNumber() == net[#net - 2].team then 
					duel_2_hero_2 = net[#net - 1].team
					duel_1_hero_2 = net[#net - 2].team
				end 
			end 
		end 

		if duel_2_hero_2 == -1 then 
			local random = RandomInt(1,2)

			local random2 = random

			repeat random2 = RandomInt(1, 2)
			until random2 ~= random

	 		duel_1_hero_2 = net[#net - random].team 
	 		duel_2_hero_2 = net[#net - random2].team 
	 	end

	end 

	if players[duel_1_hero_1] and players[duel_1_hero_2]
	and players[duel_2_hero_1] and players[duel_2_hero_2] then 


		my_game:InitDuel(players[duel_1_hero_1],players[duel_1_hero_2], 0, duel_3_only_mid)
		my_game:InitDuel(players[duel_2_hero_1],players[duel_2_hero_2], 0, false)
	end 

else 
	if #net > 2 then 


		local team_1 = nil 
		local team_2 = nil

		for team,player in pairs(players) do 
			if player.won_duel == 1 then 
				team_1 = team
			end 
		end 

		if team_1 == nil then 
			team_1 = net[#net].team

			if not players[team_1] then return end 

			if players[team_1].last_enemy and players[team_1].last_enemy:GetTeamNumber() then 

				if players[team_1].last_enemy:GetTeamNumber() == net[1].team then 
					team_2 = net[2].team
				end 

				if players[team_1].last_enemy:GetTeamNumber() == net[2].team then 
					team_2 = net[1].team
				end 
			end 

			if team_2 == nil then 
				team_2 = net[RandomInt(1, #net - 1)].team
			end 
		else 
			for team,player in pairs(players) do 
				if player.won_duel == 0 then 
					team_2 = team
				end 
			end 
		end 


		if players[team_1] and players[team_2] then 
			my_game:InitDuel(players[team_1],players[team_2], 0, false)
		end 

		for team,player in pairs(players) do 
			player.won_duel = 0
		end 

	end 
end 


end 




function my_game:destroy_tower( t , team )

local tower = nil
if t ~= nil then 
	tower = t
end

if team ~= nil and towers[team] ~= nil then 
	tower = towers[team]
end


local fillers = FindUnitsInRadius(tower:GetTeamNumber(), tower:GetAbsOrigin(), nil, 1200, DOTA_UNIT_TARGET_TEAM_FRIENDLY, DOTA_UNIT_TARGET_BUILDING, DOTA_UNIT_TARGET_FLAG_INVULNERABLE, FIND_CLOSEST, false)
for _,i in ipairs(fillers) do
	if i ~= tower and i ~= teleports[tower:GetTeamNumber()] then 

		i:RemoveModifierByName("modifier_invulnerable")

		i:ForceKill(false)
	end
end

if teleports[tower:GetTeamNumber()] ~= nil then
	teleports[tower:GetTeamNumber()]:AddNewModifier(nil, nil, "modifier_invulnerable", {})
end

if team ~= nil then 

	if towers[team] ~= nil and towers[team]:IsAlive() then 
		towers[team]:ForceKill(false)
	end
	towers[team] = nil
end



end





function my_game:CheckParty(id)

local p = PartyTable[id]


if p == nil or p == '0' then return false end

for i,party in pairs(PartyTable) do 
	
	if party == p and i ~= id then  
		local hero = GlobalHeroes[i]

		if hero ~= nil then 

			if players[hero:GetTeamNumber()] ~= nil then 
				return true
			end

		end

	end
end

return false
end


function my_game:GiveGlobalVision(kv)
	if kv.PlayerID == nil then return end

local team = PlayerResource:GetTeam(kv.PlayerID)

if my_game:CheckParty(kv.PlayerID) == true then
 CustomGameEventManager:Send_ServerToPlayer(PlayerResource:GetPlayer(kv.PlayerID), "CreateIngameErrorMessage", {message = "teammate_alive"})
 return
end



AddFOWViewer(team,Vector(0,0,0), 10000, 99999, false) 
AddFOWViewer(team,Vector(5000,0,0), 10000, 99999, false) 
AddFOWViewer(team,Vector(-5000,0,0), 10000, 99999, false) 
AddFOWViewer(team,Vector(0,5000,0), 10000, 99999, false) 
AddFOWViewer(team,Vector(0,-5000,0), 10000, 99999, false) 
AddFOWViewer(team,Vector(5000,5000,0), 10000, 99999, false) 
AddFOWViewer(team,Vector(-5000,-5000,0), 10000, 99999, false) 
AddFOWViewer(team,Vector(5000,-5000,0), 10000, 99999, false) 
AddFOWViewer(team,Vector(-5000,5000,0), 10000, 99999, false) 

--No_end_screen[kv.PlayerID] = true
end


function my_game:calc_rating( avg, rating, place, id )
if not rating then return 0 end
if GetMapName() == "unranked" then return 0 end
if SafeToLeave == true then return 0 end

local diff = rating - avg
local coef = 1


if diff > 300 then
    diff = math.min( 650, diff )
    diff = diff - 300

    if ( tonumber( place ) > 3 ) then
        coef = 1 + diff / 300
    else
        coef = 1 - diff / 300 / 1.3
    end
end

local r = math.floor( RATING_CHANGE_BASE[place] * coef )

if lobby_double_rating[id] == true then 
	r = r*2
end
if wrong_map_players[id] == true then 
	--r = math.min(r, 0)
end

return r or 0

end



function my_game:DestroyPlayerUnits(team)

local player = players[team]

if not player then return end 

for _,mod in pairs(player:FindAllModifiers()) do
	if mod:GetName() == "modifier_ember_spirit_fire_remnant_custom_timer" then
		mod:Destroy()
	end
end


local icon_name = player:GetUnitName() .. "_icon"

local allunits = FindUnitsInRadius( DOTA_TEAM_NOTEAM, Vector(0, 0, 0), nil, FIND_UNITS_EVERYWHERE, DOTA_UNIT_TARGET_TEAM_BOTH, DOTA_UNIT_TARGET_ALL, DOTA_UNIT_TARGET_FLAG_MAGIC_IMMUNE_ENEMIES + DOTA_UNIT_TARGET_FLAG_INVULNERABLE + DOTA_UNIT_TARGET_FLAG_OUT_OF_WORLD, 0, false)


for _,unit in ipairs(allunits) do
	if unit and not unit:IsNull() and unit ~= player and unit:GetUnitName() ~= "npc_teleport" then 

		for _, mod in pairs(unit:FindAllModifiers()) do
			if not mod:IsNull() and mod:GetCaster() then
				if mod:GetCaster():GetTeamNumber() == team then

					if mod:GetName() == "modifier_monkey_king_wukongs_command_custom_soldier" then  
						UTIL_Remove(unit)
						break
					else 
						mod:Destroy()
					end
				end
			end
		end

		if unit and not unit:IsNull() then 

			if unit:GetTeamNumber() == team then
				
				unit:Kill(nil, nil)

				if unit:IsCourier() then 
					UTIL_Remove(unit)
				end 
			else 

				if unit:GetUnitName() == icon_name then
					unit:Kill(nil, nil)
				end
			end

		end 

	end

end



local thinkers = Entities:FindAllByClassname("npc_dota_thinker")

for _, thinker in pairs(thinkers) do
	if thinker:GetTeamNumber() == player:GetTeamNumber() then
		UTIL_Remove(thinker)
	end
end



end 



function my_game:destroy_player(p)
if players[p] == nil then
	return
end
local id = players[p]:GetPlayerOwnerID()

if players[p].place == -1 then
    _G.Deaths = _G.Deaths + 1
    players[p].place = PlayerCount - Deaths + 1
    HTTP.playersData[id].place = PlayerCount - Deaths + 1
end

HTTP.FillItemsData(id, PlayerCount - Deaths + 1)

HTTP.SavePlayerItems( players[p]:GetPlayerOwnerID() )
HTTP.SavePlayerBuffsTalents( players[p]:GetPlayerOwnerID() )

my_game:DestroyPlayerUnits(p)



if players[p]:IsAlive() then
	local mod = players[p]:AddNewModifier(players[p], nil, "modifier_death", {})

	for i = 0, 5 do
		local item = players[p]:GetItemInSlot(i)

		if item and item:GetName() == "item_aegis" then
			item:Destroy()
		end
	end

	players[p]:Kill(nil, nil)
end




players[p]:RemoveModifierByName("modifier_aegis_custom")
players[p]:SetTimeUntilRespawn(-1)
players[p]:SetBuyBackDisabledByReapersScythe(true)

players[p].on_streak = false

players[p].defeated = true

End_net[id] = PlayerResource:GetNetWorth(id)



HTTP.playersData[id].wrong_map_status = players[p].wrong_map_status

Deaths_Players[id] = {
	items = {},
	player = players[p]
}
for i = 0, 5 do
	local item = players[p]:GetItemInSlot(i)
	local name = ""
	if item then
		name = item:GetName()
	end
	Deaths_Players[id].items[#Deaths_Players[id].items + 1] = name
end

local server_player = HTTP.GetPlayerData(id)
local rating = 0
if server_player ~= nil then
	rating = server_player.rating
end


local hero_name = ""

if GlobalHeroes[id] then 
	hero_name = GlobalHeroes[id]:GetUnitName()
end

CustomNetTables:SetTableValue(
	"networth_players",
	tostring(id),
	{
		net = End_net[id],
		place = players[p].place,
		purple = players[p].purple,
		streak = players[p].on_streak,
		rating_before = math.max(0, rating + my_game:calc_rating( avg_rating, lobby_rating[id], HTTP.playersData[id].place, id )),
		rating_change = my_game:calc_rating( avg_rating, lobby_rating[id], HTTP.playersData[id].place, id ),
		items = Deaths_Players[id].items,
		damage_bonus = players[p].damage_bonus,
		hero_name = hero_name
	}
)



CustomGameEventManager:Send_ServerToAllClients("pause_end", {id = id})
--CustomGameEventManager:Send_ServerToPlayer(PlayerResource:GetPlayer(id), "hide_pause_info_timer", {})

if duel_data[players[p].duel_data] and duel_data[players[p].duel_data].finished == 0 then 

	local duel = duel_data[players[p].duel_data]

	duel.finished = 1
	duel.hero1.duel_data = -1
	duel.hero2.duel_data = -1

	if duel.thinker and not duel.thinker:IsNull() then 
		duel.thinker:RemoveModifierByName("modifier_duel_field_thinker")
	end 
end


local heroes_left = {}

for team,player in pairs(players) do 
	if team ~= p then
		heroes_left[#heroes_left + 1] = player
	end
end


if #heroes_left == 3 then

	CustomGameEventManager:Send_ServerToAllClients( 'destroy_tower', {} )

	local dire_count = 0
	local radiant_count = 0

	for i = 1, 11 do
		if i ~= p and players[i] ~= nil then
			--for j = 1, 11 do

				--if players[j] ~= nil and j ~= p and j ~= i  then
				--	local team_viewer = tonumber(teleports[j]:GetName())

				--	local Vector_fow =
				--		Vector(vision_abs[team_viewer][1], vision_abs[team_viewer][2], vision_abs[team_viewer][3])
				--	AddFOWViewer(i, Vector_fow, vision_abs[team_viewer][4], 99999, true)

					--Vector_fow =
				--		Vector(vision_abs[team_viewer][5], vision_abs[team_viewer][6], vision_abs[team_viewer][7])
					--AddFOWViewer(i, Vector_fow, vision_abs[team_viewer][8], 99999, true)

				--	Vector_fow = towers[j]:GetAbsOrigin()
					--AddFOWViewer(i, Vector_fow, 1000, 99999, true)
			--	end
		--	end

			if players[i]:HasModifier("modifier_target") then
				players[i]:RemoveModifierByName("modifier_target")
			end
			local team_viewer = tonumber(teleports[i]:GetName())

			if team_viewer == 3 or team_viewer == 8 or team_viewer == 9 then
				dire_count = dire_count + 1
			else
				radiant_count = radiant_count + 1
			end
		end
	end

	if radiant_count > dire_count then
		my_game.patrol_dontgo_radiant = true
	else
		my_game.patrol_dontgo_dire = true
	end

	if dire_count == 3 then
		my_game.patrol_dontgo_radiant = true
	end

	if radiant_count == 3 then
		my_game.patrol_dontgo_dire = true
	end
end

if #heroes_left == 2 then

	for _,player in pairs(heroes_left) do 
		player:RemoveModifierByName("modifier_player_damage")
		player.damage_bonus = 0
	end

    my_game:InitDuel(heroes_left[1], heroes_left[2], 1, false)

end

if #heroes_left == 1 then 
    local winner = players[heroes_left[1]:GetTeamNumber()]
    winner.place = 1
    my_game:WinTeam(winner)
end

HTTP.PlayerEnd( players[p]:GetPlayerOwnerID() )

if PlayerCount == 1  then
    my_game:WinTeam(players[p])
end

players[p] = nil

if #heroes_left == 3 then 
	if my_game:IsDuelWave() then 
		for _,duel in pairs(duel_data) do 
			duel.finished = 1
			if duel.hero1 then 
				duel.hero1.duel_data = -1
			end 

			if duel.hero2 then 
				duel.hero2.duel_data = -1
			end
		end 
		
		CustomGameEventManager:Send_ServerToAllClients( "generic_sound", {sound = "Duel.Normal"} )
		my_game:FindDuelPairs()
	end 
end 


end




 




_G.SelectedHeroes = {}
_G.SelectedBases = {}
_G.SelectedQuests = {}

_G.spawn_table = {}
_G.max_per_tick = 6

function my_game:AsyncSpawn()
local limit = 0

while true do 
	local callback = spawn_table[1]
	
	if not callback then 
		return 0
	end

	table.remove(spawn_table,1)
	callback()


	limit = limit + 1
	if limit >= max_per_tick then 
		return 0
	end
end

end


function my_game:CreateUnitCustom(name, vector, clear_space, npc_owner, entity_owner, team, callback)
table.insert(spawn_table, function() 
	callback(CreateUnitByName(name, vector, clear_space, npc_owner, entity_owner, team))
end)

end



local couriers_spawned = {}


function check_death()
for id = 0,24 do 
 	if PlayerResource:IsValidPlayerID(id) and PlayerResource:GetSteamAccountID(id) ~= 0 then 
		if not couriers_spawned[id] and GlobalHeroes[id] then 

			local player = PlayerResource:GetPlayer(id)
			if player ~= nil then
				local courier = player:SpawnCourierAtPosition(COUR_POSITION[LOBBY_PLAYERS[id].select_base])
				courier:AddNewModifier(courier, nil, "modifier_invun", {})
				couriers_spawned[id] = true
			end

		end
 	end
end

--if GameRules:GetDOTATime(false, false) < 2 then return 0 end
my_game:AsyncSpawn()


for i = 1,11 do
	local tower = towers[i]
	local player = players[i]


	if tower ~= nil and player ~= nil then 

		local state = PlayerResource:GetConnectionState(player:GetPlayerOwnerID())
		local id_ban = my_game.banned_ids[tostring(PlayerResource:GetSteamAccountID(player:GetPlayerOwnerID()))]

		if not tower:IsAlive() or state == DOTA_CONNECTION_STATE_ABANDONED or player.banned or id_ban then


			if not tower:IsAlive() then 
			 	Timers:CreateTimer(0.5, function()

					local hero_won = ''
			 		if tower.killer ~= nil then 
			 			hero_won = tower.killer:GetUnitName()
			 			HTTP.playersData[player:GetPlayerOwnerID()].killer = hero_won
			 		end
			 		
					CustomGameEventManager:Send_ServerToAllClients( 'hero_lost', {ban = 0, abbandon = 0, hero2 = hero_won, hero = player:GetUnitName()} )
				 end)
			end  

			local alert = false

			if state == DOTA_CONNECTION_STATE_ABANDONED and player.left_game == false and Game_end == false then 

				player.left_game = true
   		   		CustomGameEventManager:Send_ServerToAllClients( 'hero_lost', {ban = 0, abbandon = 1, hero2 = '', hero = player:GetUnitName()} )
   		   		alert = true
			end


			if (player.banned == 1 or player.banned == true or id_ban) and alert == false then
				CustomGameEventManager:Send_ServerToAllClients( 'hero_lost', {ban = 1, abbandon = 0, hero2 = '', hero = player:GetUnitName()} )

				if player.teammate then 
					CustomGameEventManager:Send_ServerToPlayer(PlayerResource:GetPlayer(player:GetPlayerOwnerID()), 'banned', {reports = player.reports, id = player.teammate, max = 6} )
				end
			end
			

			if player.left_game_timer < 1 or player.banned == true or id_ban or player.banned == 1 or not tower:IsAlive() then  
				my_game:destroy_player(i)
				my_game:destroy_tower(tower,tower:GetTeamNumber())
			end
		end
	end

end


if SafeToLeave_alert == false and SafeToLeave == true and HTTP.serverData.isStatsMatch == true then 
	SafeToLeave_alert = true 
	CustomGameEventManager:Send_ServerToAllClients( 'saveleave', {reason = SafeToLeave_reason} )
end


return 0
end


function check_connect()
if not IsServer() then return end


if SafeToLeave == false and GameRules:GetDOTATime(false, false) < 3 then 
	for id = 0, 24 do
    	local data = CustomNetTables:GetTableValue("server_data", tostring(id) )
    	
    	if data and data.wrong_map_status == 2 then 
			_G.SafeToLeave = true
			SafeToLeave_reason = 2
			break
		end
	end
end


for id = 0, 24 do
    if PlayerResource:IsValidPlayerID(id) and PlayerResource:GetSteamAccountID(id) ~= 0 then

    	local state = PlayerResource:GetConnectionState(id)

    	local n = 0
    	for _,data in pairs(abandon_players) do 
    		n = n + 1
    	end


    	if ((state == DOTA_CONNECTION_STATE_ABANDONED) or (state == DOTA_CONNECTION_STATE_DISCONNECTED and n == PlayerCount - 1))
    	 and abandon_players[id] ~= true then 

    		abandon_players[id] = true

    		HTTP.playersData[id].isLeaver = true

    		local data = CustomNetTables:GetTableValue("server_data", tostring(id) )
    		local wrong_map_status = data.wrong_map_status


    		local lp_games = 0
    		local switch_safetoleave = false
			local lp_games = data.lp_games_remaining

			if HTTP.serverData.isStatsMatch == true and SafeToLeave == false and GameRules:GetDOTATime(false, false) <= LowPriorityTime and HTTP.playersData[id].lost_game == false then 

				lp_games = lp_games + 1

                _G.SafeToLeave = true
                switch_safetoleave = true 
                SafeToLeave_reason = 1

            end

			data.lp_games_remaining = lp_games
            data.switch_safetoleave = switch_safetoleave


			CustomNetTables:SetTableValue("server_data", tostring(id), data)

			HTTP.PlayerLeave( id )

    	end

    end
end


return 0.5
end






function my_game:check_used( t , n ) 
	if #t == 0 then return false end
	for i = 1,#t do
		if t[i] == n then return true end
	end	
	return false
end	






function my_game:WinTeam(player)
if test then 
	--return 
end


_G.Game_end = true
local last_id = player:GetPlayerOwnerID()

HTTP.playersData[last_id].place = 1


HTTP.FillItemsData(last_id, 1)
HTTP.SavePlayerItems( last_id )
HTTP.SavePlayerBuffsTalents( last_id )

HTTP.playersData[last_id].wrong_map_status = player.wrong_map_status

End_net[last_id] = PlayerResource:GetNetWorth(last_id)
Deaths_Players[last_id] = {
    player = player,
    items = {}
}

for i = 0,5 do
    local item = player:GetItemInSlot(i)
    local name = ""
    if item then     
        name = item:GetName()
    end
    table.insert(Deaths_Players[last_id].items, name)
end

HTTP.PlayerEnd( last_id )


HTTP.Request( "/anal", HTTP.ItemsData, function() end, nil, true)

for id = 0, 24 do
    if PlayerResource:IsValidPlayerID(id) and PlayerResource:GetSteamAccountID(id) ~= 0 and Deaths_Players[id] ~= nil then

    	local change = lobby_rating_change[id]
    	local before = 0

    	if change and lobby_rating_change[id] then 
    		before = lobby_rating[id] + lobby_rating_change[id]
    	end

    	local hero_name = ""
    	if GlobalHeroes[id] then 
    		hero_name = GlobalHeroes[id]:GetUnitName()
    	end

		CustomNetTables:SetTableValue(
		    "networth_players",
		    tostring(id),
		    {
				net = PlayerResource:GetNetWorth(id),
		        place = Deaths_Players[id].player.place,
		        purple = 0,
		        streak = false,
		        rating_before = math.max(0,  before),
		        rating_change = change,
		        items = Deaths_Players[id].items,
		        damage_bonus = Deaths_Players[id].player.damage_bonus,

		    	hero_name = hero_name
		    }
		)

  		HTTP.PlayerLeave( id )
    end
end


if dont_end_game == false then 
	CustomNetTables:SetTableValue("networth_players", "", {game_ended = true})
end

end


function my_game:GetHeroType( player )
if not IsServer() then return end

if player:GetUnitName() == "npc_dota_hero_juggernaut" then return {"melle","mage"} end 
if player:GetUnitName() == "npc_dota_hero_phantom_assassin" then return {"melle"}  end 
if player:GetUnitName() == "npc_dota_hero_terrorblade" then return {"melle"}  end 
if player:GetUnitName() == "npc_dota_hero_nevermore" then return {"mage"}  end 
if player:GetUnitName() == "npc_dota_hero_puck" then return {"mage"} end 
if player:GetUnitName() == "npc_dota_hero_queenofpain" then return {"mage"} end 
if player:GetUnitName() == "npc_dota_hero_huskar" then return {"mage"} end 
if player:GetUnitName() == "npc_dota_hero_bristleback" then return {"mage","melle"} end 
if player:GetUnitName() == "npc_dota_hero_legion_commander" then return {"mage","melle"} end 
if player:GetUnitName() == "npc_dota_hero_void_spirit" then return {"melle","mage"} end 
if player:GetUnitName() == "npc_dota_hero_ember_spirit" then return {"melle","mage"} end 
if player:GetUnitName() == "npc_dota_hero_pudge" then return {"melle","mage"} end 
if player:GetUnitName() == "npc_dota_hero_hoodwink" then return {"mage"} end 
if player:GetUnitName() == "npc_dota_hero_skeleton_king" then return {"melle"} end
if player:GetUnitName() == "npc_dota_hero_lina" then return {"mage"} end 
if player:GetUnitName() == "npc_dota_hero_troll_warlord" then return {"melle","mage"} end 
if player:GetUnitName() == "npc_dota_hero_axe" then return {"melle","mage"} end 
if player:GetUnitName() == "npc_dota_hero_alchemist" then return {"melle","mage"} end 
if player:GetUnitName() == "npc_dota_hero_ogre_magi" then return {"melle","mage"} end 
if player:GetUnitName() == "npc_dota_hero_antimage" then return {"melle"} end 
if player:GetUnitName() == "npc_dota_hero_primal_beast" then return {"melle","mage"} end 
if player:GetUnitName() == "npc_dota_hero_marci" then return {"melle","mage"} end 
if player:GetUnitName() == "npc_dota_hero_templar_assassin" then return {} end 
if player:GetUnitName() == "npc_dota_hero_bloodseeker" then return {"melle","mage"} end 
if player:GetUnitName() == "npc_dota_hero_monkey_king" then return {"melle","mage"} end 
if player:GetUnitName() == "npc_dota_hero_mars" then return {"melle","mage"} end 
if player:GetUnitName() == "npc_dota_hero_zuus" then return {"mage"} end 
if player:GetUnitName() == "npc_dota_hero_leshrac" then return {"mage"} end 
if player:GetUnitName() == "npc_dota_hero_crystal_maiden" then return {"mage"} end 
if player:GetUnitName() == "npc_dota_hero_snapfire" then return {"mage"} end 
if player:GetUnitName() == "npc_dota_hero_sven" then return {"melle"} end 
if player:GetUnitName() == "npc_dota_hero_sniper" then return {"mage"} end 
if player:GetUnitName() == "npc_dota_hero_muerta" then return {"mage"} end 
if player:GetUnitName() == "npc_dota_hero_pangolier" then return {"melle","mage"} end 
if player:GetUnitName() == "npc_dota_hero_arc_warden" then return {"mage"} end 
if player:GetUnitName() == "npc_dota_hero_invoker" then return {"mage"} end 
if player:GetUnitName() == "npc_dota_hero_razor" then return {"mage"} end 
if player:GetUnitName() == "npc_dota_hero_sand_king" then return {"melle","mage"} end 
end





function my_game:GetTowerDamage( player )
if not IsServer() then return end

if player:GetUnitName() == "npc_dota_hero_juggernaut" then return -30 end 
if player:GetUnitName() == "npc_dota_hero_phantom_assassin" then return -20  end 
if player:GetUnitName() == "npc_dota_hero_terrorblade" then return -60  end 
if player:GetUnitName() == "npc_dota_hero_nevermore" then return -60  end 
if player:GetUnitName() == "npc_dota_hero_puck" then return 10 end 
if player:GetUnitName() == "npc_dota_hero_queenofpain" then return -20 end 
if player:GetUnitName() == "npc_dota_hero_huskar" then return -40 end 
if player:GetUnitName() == "npc_dota_hero_bristleback" then return -60 end 
if player:GetUnitName() == "npc_dota_hero_legion_commander" then return -60 end 
if player:GetUnitName() == "npc_dota_hero_void_spirit" then return -20 end 
if player:GetUnitName() == "npc_dota_hero_ember_spirit" then return -20 end 
if player:GetUnitName() == "npc_dota_hero_pudge" then return -20 end 
if player:GetUnitName() == "npc_dota_hero_hoodwink" then return 0 end 
if player:GetUnitName() == "npc_dota_hero_skeleton_king" then return -20 end 
if player:GetUnitName() == "npc_dota_hero_lina" then return -50 end 
if player:GetUnitName() == "npc_dota_hero_troll_warlord" then return -60 end 
if player:GetUnitName() == "npc_dota_hero_axe" then return 0 end 
if player:GetUnitName() == "npc_dota_hero_alchemist" then return -60 end 
if player:GetUnitName() == "npc_dota_hero_ogre_magi" then return -20 end 
if player:GetUnitName() == "npc_dota_hero_antimage" then return -40 end 
if player:GetUnitName() == "npc_dota_hero_primal_beast" then return -40 end 
if player:GetUnitName() == "npc_dota_hero_marci" then return -30 end 
if player:GetUnitName() == "npc_dota_hero_templar_assassin" then return -50 end 
if player:GetUnitName() == "npc_dota_hero_bloodseeker" then return -50 end 
if player:GetUnitName() == "npc_dota_hero_monkey_king" then return -40 end 
if player:GetUnitName() == "npc_dota_hero_mars" then return -40 end 

end













local icons_abs = 
{
	{},
	{-6695,-6750,119},
	{6770,6706,95},
	{},
	{},
	{-6297,2778,103},
	{2849,-6383,95},
	{-2648,6426,103},
	{6520,-2632,95},

}
function CreateDamageData()
    return {
        dealt_pre_reduction = { 0, 0, 0, 0 },
        dealt_post_reduction = { 0, 0, 0, 0 },
        received_pre_reduction = { 0, 0, 0, 0 },
        received_post_reduction = { 0, 0, 0, 0 },
    }
end


my_game.banned_ids = 
{


}

function my_game:IsPatrol(name)
if name == "patrol_melee_good" or 
	name == "patrol_range_good" or 
	name == "patrol_melee_bad" or
	name == "patrol_range_bad" then return true end

return false
end


function my_game:initiate_player(player, pause, randomed)
player:Stop()




players[player:GetTeamNumber()] = player
player.choise = {}
player.HeroType = my_game:GetHeroType(player)
player.upgrades = {}
player.IsChoosing = false
player.bluepoints = 0
player.purplepoints = 0
player.death = 0
player.purple = 0
player.chosen_skill = 0
player.givegold = false
player.respawn_mod = {}
player.place = -1
player.NeutraItems = {0, 0, 0, 0, 0}
player.bluemax = StartBlue
player.purplemax = StartPurple
player.on_streak = false
player.ActiveWave = nil
player.choise_table = {}
player.Players_Died = 0
player.banned = false
player.randomed = randomed

player.necro_cd = 0

player.wrong_map_status = 0

player.reports = 0

player.after_pause_time = 0

player.grenade_count = 0
player.grenade_creeps_count = 0

player.kills_done = 0
player.towers_destroyed = 0
player.bounty_runes_picked = 0

player.can_refresh_choise = false
player.no_purple = 0
player.necro_wave = false
player.active_necro = false
player.give_lownet = 0
player.lowest_net = 0

player.trap_wave = false

player.can_refresh = true

player.no_buyback = 0

player.creeps_upgrade = 0

player.left_game = false
player.left_game_timer = 60

player.duel_data = -1
player.won_duel = 0
player.last_enemy = nil

player.pause_time = pause
player.pause = -1

player.x_min = -8100
player.x_max = 8100
player.y_min = -8100
player.y_max = 8100
player.z = 215

player.PickOrbs = 0
player.HideDouble = 0

player.orange_count = 0

player.patrol_kills = 0
player.seconds_dead = 0
player.obs_placed = 0
player.sentry_placed = 0
player.obs_kills = 0
player.sentry_kills = 0
player.defeated = false

player.damage_bonus = 0

player.abilities = {}

player.creep_damage = CreateDamageData()
player.tower_damage = CreateDamageData()
player.hero_damage = CreateDamageData()



player.hero_kills = {}

player.ItemsTiming = 
{	
	[20] = false,
	[40] = false,
	[120] = false,
	[300] = false,
	[600] = false,
	[900] = false,
	[1200] = false,
	[1800] = false,
	[2400] = false
}


local id = player:GetPlayerOwnerID()

player.hero_tier = -1


local bkb_effects = player:AddAbility("custom_bkb_effects")
bkb_effects:SetLevel(1)

if player:HasAbility("alchemist_goblins_greed_custom") then 
	player:FindAbilityByName("alchemist_goblins_greed_custom"):SetLevel(1)
end

if player:HasAbility("muerta_pierce_the_veil_custom") then 
	player:AddNewModifier(player, player:FindAbilityByName("muerta_pierce_the_veil_custom"), "modifier_muerta_pierce_the_veil_custom_tracker", {})
end


if custom_voice[player:GetUnitName()] then 
	player:AddNewModifier(player, nil, "modifier_voice_module", {})
end 

player:AddNewModifier(player, nil, "modifier_portrait_donate_custom", {})

player:AddNewModifier(player, nil, "modifier_percent_stats", {})

local mod = player:FindModifierByName("modifier_item_custom_dust_charges")

if mod then 
	mod:SetStackCount(3)
end


local sub_data = CustomNetTables:GetTableValue("sub_data", tostring(id))

if sub_data and sub_data.heroes_data[player:GetUnitName()] and sub_data.subscribed == 1 then 
	player.hero_tier = sub_data.heroes_data[player:GetUnitName()].tier
end

chat_wheel:SetDefaultSound(id)

    
if HTTP.GetPlayerData(id) then 
   	player.islp = HTTP.GetPlayerData(id).lowPriorityRemaining > 0
end

Timers:CreateTimer(0.2, function()
	player:HeroLevelUp(false)
	player:HeroLevelUp(false)
end)

if false and test and not player.is_bot then 

	local tp_item1 = CreateItem("item_legendary_upgrade", player, player)
	player:AddItem(tp_item1)

	tp_item1 = CreateItem("item_gray_upgrade", player, player)
	player:AddItem(tp_item1)

	tp_item1 = CreateItem("item_purple_upgrade", player, player)
	player:AddItem(tp_item1)

	tp_item1 = CreateItem("item_blue_upgrade", player, player)
	player:AddItem(tp_item1)
end 



for _,name in pairs(start_abilities) do 
	local ability = player:FindAbilityByName(name)
	if ability then 
		ability:SetLevel(1)
	end
end


if player:GetUnitName() == "npc_dota_hero_pudge" then
    local ability = player:FindAbilityByName("custom_pudge_flesh_heap")
    player:AddNewModifier(player, ability, "modifier_custom_pudge_flesh_heap", {})
end

if player:FindAbilityByName("monkey_king_mischief_custom") then 
	player:FindAbilityByName("monkey_king_mischief_custom"):SetLevel(1)
end



player:AddNewModifier(nil, nil, "modifier_on_respawn", {})


Timers:CreateTimer(1, function() 
	player:AddNewModifier(player, nil, "modifier_player_damage", {})
end)


local tp_item = CreateItem("item_tpscroll_custom", player, player)
player:AddItem(tp_item)




CustomNetTables:SetTableValue("custom_items_button", tostring(id), {observer = 0, sentry = 0})

local lvl = -1
local hero_name = player:GetUnitName()

if sub_data then 


	if sub_data.heroes_data[hero_name] and sub_data.heroes_data[hero_name].has_level == 1 and sub_data.subscribed == 1 and sub_data.hide_tier == 0 then
		lvl = sub_data.heroes_data[hero_name].tier 

	end

	shop:AddPetFromStart(id)

	chat_wheel:SetDefaultSound(id)
	
end



CustomNetTables:SetTableValue("hero_portrait_levels", tostring(hero_name), {tier = lvl})


if player:GetQuest() == nil and SelectedQuests[id] ~= nil then

	local quest_table = {}
	quest_table.name = SelectedQuests[id]


	local quests_data = CustomNetTables:GetTableValue("hero_quests", tostring(id));

	for hero_name,quest in pairs(quests_data) do 

		if hero_name == player:GetUnitName() then 

			for _,hero_quest in pairs(quest) do 
				if hero_quest.name == SelectedQuests[id] then 

					quest_table.exp = hero_quest.exp
					quest_table.shards = hero_quest.shards
					quest_table.icon = hero_quest.icon
					quest_table.goal = hero_quest.goal
					quest_table.legendary = hero_quest.legendary
					quest_table.number = hero_quest.number
				end
			end
		end
	end


	player:SetQuest(quest_table)
end



if HTTP.GetPlayerData(id) then 
    CustomNetTables:SetTableValue("TipsType", tostring(id), {type = HTTP.GetPlayerData(id).tipsType})
end

CustomGameEventManager:Send_ServerToPlayer(PlayerResource:GetPlayer(id), "kill_progress", {blue = player.bluepoints, purple = player.purplepoints, max = StartBlue, max_p = StartPurple} )
	
CustomGameEventManager:Send_ServerToPlayer(PlayerResource:GetPlayer(id), 'init_damage_table', {	} ) 

CustomGameEventManager:Send_ServerToPlayer(PlayerResource:GetPlayer(id), 'change_show_level_lua', {}) 

if (test and sub_data) or (sub_data and tostring(GetMapName()) ~= "unranked" and HTTP.IsValidGame(PlayerCount)) then 
    CustomGameEventManager:Send_ServerToPlayer(PlayerResource:GetPlayer(id), 'init_double_rating', {cd = sub_data.double_rating_cd, subscribed = sub_data.subscribed} ) 
end

end



	





function my_game:initiate_tower()



local buildings = FindUnitsInRadius(DOTA_TEAM_NOTEAM, Vector(0,0,0), nil, FIND_UNITS_EVERYWHERE, DOTA_UNIT_TARGET_TEAM_BOTH, DOTA_UNIT_TARGET_BUILDING + DOTA_UNIT_TARGET_BASIC, DOTA_UNIT_TARGET_FLAG_INVULNERABLE, FIND_CLOSEST, false)


for _,building in ipairs(buildings) do
  	if building and not building:IsNull() and building:GetTeamNumber() == DOTA_TEAM_CUSTOM_6 then 

		if (building:GetUnitName() == "npc_towerdire" or building:GetUnitName() == "npc_towerradiant") then
			local j = building
			building:RemoveModifierByName("modifier_invulnerable")

			self:destroy_tower(building)
			j:Destroy()
    	else 

	    	if building:GetUnitName() == "npc_teleport" then
				building:AddNewModifier(nil, nil, "modifier_invulnerable", {})
			end
		end
    end
end



for _,tower in pairs(towers) do

	if players[tower:GetTeamNumber()] ~= nil then 

 		for _,tt in pairs(towers) do 
 			if tt:GetTeamNumber() ~= tower:GetTeamNumber() then 
			   	local name = SelectedHeroes[players[tower:GetTeamNumber()]:GetPlayerOwnerID()].hero .. '_icon'
			    local vector = Vector(icons_abs[players[tower:GetTeamNumber()]:GetTeamNumber()][1],icons_abs[players[tower:GetTeamNumber()]:GetTeamNumber()][2],icons_abs[players[tower:GetTeamNumber()]:GetTeamNumber()][3])
				local hero_icon = CreateUnitByName(name, tower:GetAbsOrigin(), false, nil, nil, tt:GetTeamNumber())
				hero_icon:AddNewModifier(nil, nil, "modifier_unselect", {})
			end
		end

	end
end



end





function my_game:IsSphere( item )
if item:GetName() == "item_legendary_upgrade" or 
	item:GetName() == "item_gray_upgrade" or
	item:GetName() == "item_blue_upgrade" or 
	item:GetName() == "item_purple_upgrade_shop" or 
	item:GetName() == "item_alchemist_recipe" or 
	item:GetName() == "item_purple_upgrade" then 
		return true end 
return false 
end

function my_game:ExecuteOrderFilterCustom( ord )



	local target = ord.entindex_target ~= 0 and EntIndexToHScript(ord.entindex_target) or nil
	local player = PlayerResource:GetPlayer(ord["issuer_player_id_const"])

	if player and player:GetAssignedHero() then 
		if player:GetAssignedHero():HasModifier("modifier_duel_hero_start") then return false end 
	end


 	local unit


    if ord.units and ord.units["0"] then
        unit = EntIndexToHScript(ord.units["0"])
    end


    local orders = {
        [DOTA_UNIT_ORDER_CAST_POSITION] = true,
        [DOTA_UNIT_ORDER_CAST_TARGET] = true,
        [DOTA_UNIT_ORDER_CAST_TARGET_TREE] = true, 
        [DOTA_UNIT_ORDER_MOVE_TO_POSITION] = true,
        [DOTA_UNIT_ORDER_MOVE_TO_TARGET] = true,
        [DOTA_UNIT_ORDER_ATTACK_MOVE] = true,
        [DOTA_UNIT_ORDER_ATTACK_TARGET] = true,
        [DOTA_UNIT_ORDER_CAST_NO_TARGET] = true,
        [DOTA_UNIT_ORDER_PICKUP_ITEM] = true,
        [DOTA_UNIT_ORDER_PICKUP_RUNE] = true,

    }

    if unit and (unit:HasModifier("modifier_custom_ability_teleport") or unit:HasModifier("modifier_patrol_warp_amulet")) then
 
    	local ability = EntIndexToHScript(ord["entindex_ability"])	

        if orders[ord.order_type] == true then 

            if ord.order_type ~= DOTA_UNIT_ORDER_CAST_NO_TARGET then 
                return false
			else 
				if ability and not my_game:ContainsValue(ability:GetBehaviorInt(), DOTA_ABILITY_BEHAVIOR_IGNORE_CHANNEL) then
                	return false
                end
           	end
        end
    end


    if ord.order_type == DOTA_UNIT_ORDER_DROP_ITEM_AT_FOUNTAIN then
    	local item_ward = EntIndexToHScript(ord["entindex_ability"])	
    	if item_ward and item_ward:GetName() == "item_observer_stackable" then 
    		return false
    	end
    end 
    


    if ord.order_type == DOTA_UNIT_ORDER_PICKUP_ITEM then

            local item = EntIndexToHScript(ord["entindex_target"])

            if item then
            		

                local pickedItem = item:GetContainedItem()
                if not pickedItem then return true end
                if pickedItem:IsNeutralDrop() then return true end
                if players[unit:GetTeamNumber()] == nil then return false end


                if my_game:IsSphere(pickedItem) and players[unit:GetTeamNumber()]:HasModifier("modifier_end_choise") then return false end


                if unit:IsCourier() and pickedItem:GetPurchaser() ~= players[unit:GetTeamNumber()]
                and (pickedItem:GetName() ~= "item_roshan_necro") and (pickedItem:GetName() ~= "item_gem") then
					CustomGameEventManager:Send_ServerToPlayer(player, "CreateIngameErrorMessage", {message = "#wrong_sphere"})
				 return false end


                if (pickedItem:GetPurchaser() ~= unit) and (pickedItem:GetName() ~= "item_rapier") and (pickedItem:GetName() ~= "item_aegis")
                and (pickedItem:GetName() ~= "item_refresher_shard") and (pickedItem:GetName() ~= "item_roshan_necro") and (pickedItem:GetName() ~= "item_gem")
                and not unit:IsCourier() then

					CustomGameEventManager:Send_ServerToPlayer(player, "CreateIngameErrorMessage", {message = "#wrong_sphere"})
                    return false
                end
            end
    end



    if not player then return false end

    local hero = player:GetAssignedHero()

    if unit and unit:IsTempestDouble() then 
    	hero = unit
    end 


    if not hero then return end




    if ord.order_type == DOTA_UNIT_ORDER_BUYBACK and not hero:IsReincarnating() then 
    	
    	Timers:CreateTimer(0.2, function() 
    		if hero and not hero:IsNull() then 
    			my_game:RefreshCooldowns(hero, true)
    		end
   		 end)

    	Timers:CreateTimer(1, function() 
    		if hero and not hero:IsNull() then 
    			hero.no_buyback = 1
    			hero:SetBuybackCooldownTime(99999)
    		end
   		 end)
    	
    end


    if ord.order_type == DOTA_UNIT_ORDER_CAST_TARGET and hero:GetUnitName() == "npc_dota_hero_alchemist" then
    	local item = EntIndexToHScript(ord.entindex_ability)
    	if item and item:GetName() == "item_ultimate_scepter" then 
			CustomGameEventManager:Send_ServerToPlayer(player, "CreateIngameErrorMessage", {message = "#alch_scepter"})
    		return false
    	end
    end


    if hero:HasModifier("modifier_duel_hero_thinker") and 
    	(ord.order_type == DOTA_UNIT_ORDER_PURCHASE_ITEM
    	or ord.order_type == DOTA_UNIT_ORDER_EJECT_ITEM_FROM_STASH) then 

    	return false
    end


     if ord.order_type == DOTA_UNIT_ORDER_CAST_TOGGLE then 


     	local ability = EntIndexToHScript(ord.entindex_ability)

     	if ability and ability:GetName() == "custom_puck_phase_shift" and hero:HasModifier("modifier_custom_puck_phase_shift_cooldown") then

     		return false 
     	end

     	if ability and not ability:IsFullyCastable() and ability:GetName() ~= "custom_puck_phase_shift" then 
     		return false
     	end

     end

    if ord.order_type == DOTA_UNIT_ORDER_PURCHASE_ITEM and players[hero:GetTeamNumber()] ~= nil and ord.shop_item_name == "item_purple_upgrade_shop" then 

    	if not players[hero:GetTeamNumber()].got_purple then 

    		players[hero:GetTeamNumber()].purple = players[hero:GetTeamNumber()].purple + 1
    		players[hero:GetTeamNumber()].got_purple = true
    	else 
    		return false
    	end
    end


    if hero and hero:HasModifier("modifier_mid_teleport_cast") and ord.order_type ~= DOTA_UNIT_ORDER_HOLD_POSITION
    and ord.order_type ~= DOTA_UNIT_ORDER_PURCHASE_ITEM and ord.order_type ~= DOTA_UNIT_ORDER_MOVE_ITEM
    and ord.order_type ~= DOTA_UNIT_ORDER_SELL_ITEM  then 
     return false end


    if hero and hero:HasModifier("modifier_bristle_spray_legendary") and hero:IsAlive() and ord.order_type == DOTA_UNIT_ORDER_CAST_TOGGLE_AUTO then 
    	local ability = EntIndexToHScript(ord.entindex_ability)
    	if ability and ability:GetName() == "bristleback_quill_spray_custom" then 
    		local mod = hero:FindModifierByName("modifier_custom_bristleback_quill_spray_legendary")
    		if not mod then 
    			hero:AddNewModifier(hero, ability, "modifier_custom_bristleback_quill_spray_legendary", {})
    		else 
    			mod:Destroy()
    		end
    	end
    end

    local ability = EntIndexToHScript(ord.entindex_ability)

    if hero and ability 
    	and hero:HasModifier("modifier_templar_assassin_meld_5")
    	and hero:IsAlive() and ord.order_type == DOTA_UNIT_ORDER_CAST_TOGGLE_AUTO then 

    	if ability and ability:GetName() == "templar_assassin_meld_custom" then 
    		local mod = hero:FindModifierByName("modifier_templar_assassin_meld_custom_toggle")
    		if not mod then 
    			hero:AddNewModifier(hero, ability, "modifier_templar_assassin_meld_custom_toggle", {})
    		else 
    			mod:Destroy()
    		end
    	end
    end


	if hero and hero:HasModifier("modifier_pangolier_gyroshell_custom") then 


		local validMoveOrders =
		{
			[DOTA_UNIT_ORDER_ATTACK_TARGET] = true,
			[DOTA_UNIT_ORDER_MOVE_TO_TARGET] = true,
			[DOTA_UNIT_ORDER_MOVE_TO_POSITION] = true,
			[DOTA_UNIT_ORDER_ATTACK_MOVE] = true,
			[DOTA_UNIT_ORDER_PICKUP_ITEM] = true,
			[DOTA_UNIT_ORDER_PICKUP_RUNE] = true,
			[DOTA_UNIT_ORDER_MOVE_TO_DIRECTION] = true,
		}

		if validMoveOrders[ord.order_type] then
			hero:FindModifierByName("modifier_pangolier_gyroshell_custom"):OnOrderCustom(Vector(ord.position_x, ord.position_y, ord.position_z), target)
			return false
		end
	end


    if hero and hero:HasModifier("modifier_lina_array_legendary") and hero:IsAlive() and ord.order_type == DOTA_UNIT_ORDER_CAST_TOGGLE_AUTO then 
    	local ability = EntIndexToHScript(ord.entindex_ability)
    	if ability and ability:GetName() == "lina_light_strike_array_custom" then 
    		local mod = hero:FindModifierByName("modifier_lina_light_strike_array_custom_legendary")
    		if not mod then 
    			hero:AddNewModifier(hero, ability, "modifier_lina_light_strike_array_custom_legendary", {})
    		else 
    			mod:Destroy()
    		end
    	end
    end




	if ord.order_type == DOTA_UNIT_ORDER_ATTACK_TARGET or ord.order_type == DOTA_UNIT_ORDER_MOVE_TO_TARGET  then



		if target and not target:IsNull() and target:IsBaseNPC() and target:GetUnitName() == "npc_teleport" and unit:IsRealHero() then

			if target:GetTeamNumber() ~= hero:GetTeamNumber() then return false end

			if unit:HasModifier("modifier_target") then 

			--	CustomGameEventManager:Send_ServerToPlayer(player, "CreateIngameErrorMessage", {message = "#midteleport_hunt"})
				--return false
			end

			if teleport_range >= ( hero:GetOrigin() - target:GetOrigin() ):Length2D() then 

				 if not hero:HasModifier("modifier_mid_teleport_cd") then
	     			hero:Interrupt() 
	     			hero:Stop()
	    		    hero:AddAbility("mid_teleport")
	      			local ability = hero:FindAbilityByName("mid_teleport")
	     			ability:SetLevel(1)
	     			ability.roshan = Active_Roshan
	    			hero:CastAbilityNoTarget(ability, hero:GetPlayerOwnerID())

	    		else 
					CustomGameEventManager:Send_ServerToPlayer(player, "CreateIngameErrorMessage", {message = "#midteleport_cd"})
	    		end
			else 
				CustomGameEventManager:Send_ServerToPlayer(player, "CreateIngameErrorMessage", {message = "#midteleport_distance"})
			end

			return false
		end
	end



	if ord.order_type == DOTA_UNIT_ORDER_CAST_TARGET  then
		if target:GetUnitName() == "npc_teleport" then 
			return false
		end
	end




	local ability = EntIndexToHScript(ord.entindex_ability)

	if not ability or not ability.GetBehaviorInt then return true end
	local behavior = ability:GetBehaviorInt()

	-- check if the ability exists and if it is Vector targeting

if bit.band(behavior, DOTA_ABILITY_BEHAVIOR_VECTOR_TARGETING) ~= 0  then



	if ord.order_type == DOTA_UNIT_ORDER_VECTOR_TARGET_POSITION then
		ability.vectorTargetPosition2 = Vector(ord.position_x, ord.position_y, 0)
	end





	if ord.order_type == DOTA_UNIT_ORDER_CAST_POSITION then
		ability.vectorTargetPosition = Vector(ord.position_x, ord.position_y, 0)
		local position = ability.vectorTargetPosition
		local position2 = ability.vectorTargetPosition2
		local direction = (position2 - position):Normalized()

		--Change direction if just clicked on the same position
		if position == position2 then
			direction = (position - unit:GetAbsOrigin()):Normalized()
		end
		direction = Vector(direction.x, direction.y, 0)
		ability.vectorTargetDirection = direction

		local function OverrideSpellStart(self, position, direction)
			self:OnVectorCastStart(position, direction)
		end
		ability.OnSpellStart = function(self) return OverrideSpellStart(self, position, direction) end
	end


	if (ord.order_type == DOTA_UNIT_ORDER_CAST_TARGET or ord.order_type == DOTA_UNIT_ORDER_CAST_TARGET_TREE)
	 and (ability:GetAbilityName() == 'muerta_dead_shot_custom' or
	 ability:GetAbilityName() == 'arc_warden_flux_custom' or ability:GetAbilityName() == 'marci_companion_run_custom' ) then

        ability.vectorTargetPosition = Vector(ord.position_x, ord.position_y, 0)

        local pos = Vector(ord.position_x, ord.position_y, 0)
        if ord["entindex_target"] then
            if EntIndexToHScript(ord["entindex_target"]) then
                pos = EntIndexToHScript(ord["entindex_target"]):GetAbsOrigin()
            end
        end

        ability.vectorTargetPoisitioncheck = pos

        local position = ability.vectorTargetPosition
        local position2 = ability.vectorTargetPosition2
        local direction = (position2 - position):Normalized()

        --Change direction if just clicked on the same position
        if position == position2 then
            direction = (position - unit:GetAbsOrigin()):Normalized()
        end

        direction = Vector(direction.x, direction.y, 0)
        ability.vectorTargetDirection = direction

        local function OverrideSpellStart(self, position, direction)
            self:OnVectorCastStart(position, direction)
        end
        
        ability.OnSpellStart = function(self) return OverrideSpellStart(self, position, direction) end
    end




end


	return true
end

function my_game:DamageFilter( dmg )

if dmg["entindex_victim_const"] == nil then return true end

local target = EntIndexToHScript(dmg["entindex_victim_const"])
local damage = dmg["damage"]
if dmg["entindex_attacker_const"] == nil then return true end

local attacker = EntIndexToHScript(dmg["entindex_attacker_const"])

if (target:GetHealth() <= 1 and target:IsRealHero()) then 
--	return false
end

if target:GetUnitName() == "npc_teleport" then
	return false
end


if attacker.owner then 
	attacker = attacker.owner
end

if target and target:IsRealHero() and not target:IsTempestDouble() and attacker:IsHero() and target:GetTeamNumber() ~= attacker:GetTeamNumber() and damage > 0 then
    local no_found = true

    if not damage_table[target:GetPlayerID()] then 
		damage_table[target:GetPlayerID()] = {}
		damage_table[target:GetPlayerID()].spell_damage = {}
		damage_table[target:GetPlayerID()].spell_damage_income = {}
	end

    if damage_table[target:GetPlayerID()] then
      	if damage_table[target:GetPlayerID()].spell_damage_income then

          	if damage_table[target:GetPlayerID()].spell_damage_income[attacker:GetUnitName()] == nil then
                  damage_table[target:GetPlayerID()].spell_damage_income[attacker:GetUnitName()] = {}
                  damage_table[target:GetPlayerID()].spell_damage_income[attacker:GetUnitName()].phys = 0
                  damage_table[target:GetPlayerID()].spell_damage_income[attacker:GetUnitName()].magic = 0
                  damage_table[target:GetPlayerID()].spell_damage_income[attacker:GetUnitName()].pure = 0
                  damage_table[target:GetPlayerID()].spell_damage_income[attacker:GetUnitName()].all_damage = 0
            end
              
            damage_table[target:GetPlayerID()].spell_damage_income[attacker:GetUnitName()].all_damage = damage_table[target:GetPlayerID()].spell_damage_income[attacker:GetUnitName()].all_damage + damage

              if dmg.damagetype_const == 1 then
                  damage_table[target:GetPlayerID()].spell_damage_income[attacker:GetUnitName()].phys = damage_table[target:GetPlayerID()].spell_damage_income[attacker:GetUnitName()].phys + damage
              elseif dmg.damagetype_const == 2 then
                  damage_table[target:GetPlayerID()].spell_damage_income[attacker:GetUnitName()].magic = damage_table[target:GetPlayerID()].spell_damage_income[attacker:GetUnitName()].magic + damage
              elseif dmg.damagetype_const == 4 then
                  damage_table[target:GetPlayerID()].spell_damage_income[attacker:GetUnitName()].pure = damage_table[target:GetPlayerID()].spell_damage_income[attacker:GetUnitName()].pure + damage
              end


              CustomNetTables:SetTableValue("player_damages_income", tostring(target:GetPlayerID()), damage_table[target:GetPlayerID()].spell_damage_income)
      	end
    end
end

if attacker and attacker:IsHero() and target:IsRealHero() and target:GetTeamNumber() ~= attacker:GetTeamNumber() and damage > 0 then
    local no_found = true

    if not damage_table[attacker:GetPlayerID()] then 
		damage_table[attacker:GetPlayerID()] = {}
		damage_table[attacker:GetPlayerID()].spell_damage = {}
		damage_table[attacker:GetPlayerID()].spell_damage_income = {}
	end

    if damage_table[attacker:GetPlayerID()] then
      	if damage_table[attacker:GetPlayerID()].spell_damage then
          	local ability_name = nil
          	local ability_type = "attack"

          	if dmg.entindex_inflictor_const ~= nil then
            	ability_name = EntIndexToHScript(dmg.entindex_inflictor_const):GetAbilityName()
          	else
              	ability_name = "attack"
          	end

          	for _, hero_table in pairs(damage_table[attacker:GetPlayerID()].spell_damage) do
              	if hero_table.name == ability_name then
                  	no_found = false
                  	if hero_table.damage then
                    	hero_table.damage = hero_table.damage + damage
                  	else
                      	hero_table.damage = damage
                  	end
              	end
          	end

          	if dmg.entindex_inflictor_const ~= nil then
              	if EntIndexToHScript(dmg.entindex_inflictor_const):IsItem() then
                	ability_type = "item"
              	else
                	ability_type = "ability"
              	end
          	else
              	ability_type = "attack"
          	end

          	if no_found then
            	table.insert(damage_table[attacker:GetPlayerID()].spell_damage, {name = ability_name, damage = damage, index = target:GetUnitName(), damage_type = dmg.damagetype_const, type = ability_type})
          	end

          	table.sort( damage_table[attacker:GetPlayerID()].spell_damage, function(x,y) return y.damage < x.damage end )

          	CustomNetTables:SetTableValue("player_damages", tostring(attacker:GetPlayerID()), damage_table[attacker:GetPlayerID()].spell_damage)
      	end
    end
end


return true
end


function my_game:HealingFilter( h )

if h["entindex_target_const"] == nil then return healing end
if h["entindex_healer_const"] == nil then return healing end
if h["heal"] == nil then return healing end

local heal = h["heal"]
local target = EntIndexToHScript(h["entindex_target_const"])
local healer = EntIndexToHScript(h["entindex_healer_const"])

	return healing
end




local first_think = true
function my_game:OnThink()
	--my_game:UpdateMatch(first_think)
	local steamIDs = {}


	for id = 0, 24 do
		if PlayerResource:IsValidPlayerID( id ) then
			table.insert( steamIDs, tostring( PlayerResource:GetSteamAccountID( id ) ) )
		end
	end

	HTTP.Request("/state", {
		playerIds = steamIDs,
	}, function(data)

		if not data then 
			return
		end

		for _, player in pairs( data ) do
			local pid = HTTP.GetPlayerBySteamID( player.playerId )
			local sub_data = CustomNetTables:GetTableValue("sub_data", tostring(pid))

			if sub_data then
				sub_data.points = player.shardsAmount
				sub_data.votes_count = player.voteCount

				if player.dotaPlusExpire and player.dotaPlusExpire > 0 and sub_data.subscribed == 0 then 
					sub_data.subscribed = 1
					sub_data.sub_time = player.dotaPlusExpire/1000
				end


				if (not player.dotaPlusExpire or player.dotaPlusExpire <= 0) and sub_data.subscribed == 1 then 
					sub_data.subscribed = 0
					sub_data.sub_time = 0
				end

   				CustomNetTables:SetTableValue("sub_data", tostring(pid), sub_data)
			else

   			end
		end
    end)


	first_think = false
	return 10
end

function my_game:AddPlayer(team)
if not IsInToolsMode() then return end

local p = FindUnitsInRadius(DOTA_TEAM_NOTEAM,Vector(0, 0, 0),nil,FIND_UNITS_EVERYWHERE,DOTA_UNIT_TARGET_TEAM_BOTH,DOTA_UNIT_TARGET_HERO,DOTA_UNIT_TARGET_FLAG_MAGIC_IMMUNE_ENEMIES,0,false)

for _,player in pairs(p) do 
	if player:GetTeamNumber() == team then 
		my_game:initiate_player(player, 30)
		--	my_game:SetBotTeleport(player)
	end
end

end



function my_game:SetBotTeleport(unit)
if not IsInToolsMode() then return end

local team = unit:GetTeamNumber()

local find_towers =  FindUnitsInRadius( team,  Vector(0,0,0), nil,  FIND_UNITS_EVERYWHERE,  DOTA_UNIT_TARGET_TEAM_BOTH,  DOTA_UNIT_TARGET_BUILDING + DOTA_UNIT_TARGET_BASIC,  DOTA_UNIT_TARGET_FLAG_INVULNERABLE, 0, false )

for _,building in ipairs(find_towers) do
	if building:GetUnitName() == "npc_teleport" and building:GetName() == tostring(team) then


		building:StartGesture(ACT_DOTA_IDLE)

		building:RemoveModifierByName("modifier_invulnerable")
		building:AddNewModifier(nil, nil, "modifier_mid_teleport", {})


		teleports[team] = building

		local number = tonumber(building:GetName())


		if number == 3 or number == 8 or number == 9 then
		  building:SetMaterialGroup("1")
		end 

		if number == 2 or number == 6 or number == 7 then
		  building:SetMaterialGroup("0")
		end 
	end
end 

end




function my_game:ClearPlayer(team)
if not IsInToolsMode() then return end

if players[team] then 

--	if duel_data[players[team].duel_data] and duel_data[players[team].duel_data].finished == 0 then 

	--	local duel = duel_data[players[team].duel_data]

	--	duel.finished = 1
	--	duel.hero1.duel_data = -1
	--	duel.hero2.duel_data = -1

	--	if duel.thinker and not duel.thinker:IsNull() then 
	--		duel.thinker:RemoveModifierByName("modifier_duel_field_thinker")
	--	end 
	--end

	players[team] = nil


	local heroes_left = {}

	for team,player in pairs(players) do 
		heroes_left[#heroes_left + 1] = player
	end 



	if #heroes_left == 2 then

		for _,player in pairs(heroes_left) do 
			player:RemoveModifierByName("modifier_player_damage")
			player.damage_bonus = 0
		end

        my_game:InitDuel(heroes_left[1], heroes_left[2], 1, false)

	end




end 

end




function my_game:InitDuel(player1, player2, final, use_base_field)
if not IsServer() then return end

if final == 1 then 

	CustomGameEventManager:Send_ServerToAllClients( "generic_sound", {sound = "FinalDuel.Start"} )
			

	for _,data in pairs(duel_data) do 
		if data.finished == 0 then 
			data.finished = 1
			data.hero1.duel_data = -1
			data.hero2.duel_data = -1

			if data.thinker and not data.thinker:IsNull() then 
				data.thinker:RemoveModifierByName("modifier_duel_field_thinker")
			end 
		end 
	end 
end 


local number = #duel_data + 1

player1.duel_data = number
player2.duel_data = number

duel_data[number] = {}

duel_data[number].hero1 = player1
duel_data[number].hero2 = player2
duel_data[number].wins1 = 0
duel_data[number].wins2 = 0
duel_data[number].final_duel = final
duel_data[number].field_created = 0
duel_data[number].field = nil
duel_data[number].rounds = 0
duel_data[number].finished = 0
duel_data[number].timer = 0
duel_data[number].max_timer = duel_timer_normal
duel_data[number].thinker = nil
duel_data[number].stage = 1
duel_data[number].top3 = 0
duel_data[number].use_base_field = -1




if use_base_field == true then
	if not player1:IsMidPlayer() then 
		duel_data[number].use_base_field = player1:GetBase()
	else 
		duel_data[number].use_base_field = player2:GetBase()
	end 
end  

if final == 1 then 
 	MaxTimer = duel_timer
 	timer = 0
	duel_data[number].max_timer = duel_timer_final
 	
end 

local count = 0

for _,player in pairs(players) do 
	count = count + 1
end 

if count == 3 then 
	duel_data[number].top3 = 1
end 

end


function my_game:CreateDuelField(index)
if not duel_data[index] then return end 
if duel_data[index].field_created == 1 then return end

local use_walls = 0
local field = 0

if duel_data[index].final_duel == 1 and duel_data[index].field then 

	if duel_data[index].field == duel_fields['1'] then 
		field = '2'
	else 
		field = '1'
	end 

else 

	if duel_data[index].use_base_field == -1 then 

		if duel_last_field == "1" then 
			duel_last_field = "2"
		else 
			duel_last_field = "1"
		end 

		field = duel_last_field
	else 
		use_walls = 1
		field = tostring(duel_data[index].use_base_field)
	end 
end 

duel_data[index].field = duel_fields[field]
duel_data[index].field_created = 1

duel_data[index].rounds = duel_data[index].rounds + 1

duel_data[index].thinker = CreateModifierThinker(nil, nil, "modifier_duel_field_thinker", {index = index, use_walls = use_walls}, duel_data[index].field.start1, DOTA_TEAM_NEUTRALS, false)


end 























--Convars:RegisterCommand('set_winner', function(_,team) my_game:WinTeam(tonumber(team)) end, '', 0)


Convars:RegisterCommand('add_player', function(_,team) my_game:AddPlayer(tonumber(team)) end, '', 0)
Convars:RegisterCommand('clear_player', function(_,team) my_game:ClearPlayer(tonumber(team)) end, '', 0)

--Convars:RegisterCommand('start_duel', function() my_game:start_duel() end, '', 0)
--Convars:RegisterCommand('destroy_tower', function(_,team) my_game:destroy_tower(nil, tonumber(team) ) end, '', 0)
